<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>New Tab</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="style.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap" rel="stylesheet">
  <link rel="icon" href="../media/favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="../media/favicon.ico" type="image/x-icon">
  <link rel="apple-touch-icon" href="../media/favicon.ico">
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            sf: [
              "-apple-system",
              "BlinkMacSystemFont",
              "San Francisco",
              "Helvetica Neue",
              "sans-serif",
            ],
            patrick: [
              "Patrick Hand",
              "cursive",
            ],
          },
        },
      },
    };
  </script>
  <script>
    async function getFaviconUrl(url) {
      try {
        const domain = new URL(url).hostname;
        // Directly use the Google Favicons API which is more reliable
        return `https://www.google.com/s2/favicons?domain=${domain}&sz=128`;
      } catch (e) {
        console.error("Error retrieving favicon:", e);
        // Return a default icon in case of error
        return 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">üåê</text></svg>';
      }
    }

    function handleShortcutClick(event, position) {
      event.preventDefault();
      const shortcut = document.querySelector(
        `[data-position="${position}"]`
      );
      const iconContainer = shortcut.querySelector(".shortcut-icon");
      const isEmpty = iconContainer.getAttribute("data-empty") === "true";

      if (event.type === "contextmenu") {
        showContextMenu(event, position);
      } else if (isEmpty) {
        openConfigModal(position);
      } else {
        performSearchRedirect(shortcut.href, shortcut.href, 5);
      }
    }

    function showContextMenu(event, position) {
      event.preventDefault();
      const contextMenu = document.getElementById("contextMenu");
      contextMenu.style.left = `${event.pageX}px`;
      contextMenu.style.top = `${event.pageY}px`;
      contextMenu.setAttribute("data-position", position);
      contextMenu.classList.remove("hidden");
      contextMenu.style.background = "none";
      contextMenu.style.backgroundColor = "transparent";

      document.addEventListener("click", closeContextMenu);
    }

    function closeContextMenu() {
      document.getElementById("contextMenu").classList.add("hidden");
      document.removeEventListener("click", closeContextMenu);
    }

    function generateShortcut(i) {
      return `
          <div class="shortcut-container" 
             ondragover="handleDragOver(event)" 
             ondrop="handleDrop(event, '${i}')"
             ondragenter="handleDragEnter(event)"
             ondragleave="handleDragLeave(event)">
             <a href="#" 
             draggable="true"
             ondragstart="handleDragStart(event, '${i}')"
             onclick="handleShortcutClick(event, '${i}')" 
             oncontextmenu="handleShortcutClick(event, '${i}')"
             data-position="${i}"
             class="group p-6 bg-white/10 rounded-2xl shadow-lg hover:shadow-xl transition-all duration-300 block backdrop-blur-xl">
              <div class="text-center">
                <div class="shortcut-icon" data-empty="true">
                </div>                <div class="text-white font-medium shortcut-title">Add a shortcut</div>
              </div>
            </a>
          </div>`;
    }

    function handleDragOver(event) {
      event.preventDefault();
    }

    function handleDragEnter(event) {
      event.preventDefault();
      const container = event.currentTarget;
      container.querySelector("a").classList.add("bg-white/40");
    }

    function handleDragLeave(event) {
      event.preventDefault();
      const container = event.currentTarget;
      container.querySelector("a").classList.remove("bg-white/40");
    }

    async function handleDrop(event, newPosition) {
      event.preventDefault();
      const container = event.currentTarget;
      container.querySelector("a").classList.remove("bg-white/40"); const oldPosition = event.dataTransfer.getData('text/plain');

      // If it's an external drag (URL)
      if (oldPosition === '') {
        // Keep the existing logic for URL drop
        const data = event.dataTransfer.getData("text");
        if (!data) return;
        try {
          const url = new URL(data);
          let title = "";
          try {
            const response = await fetch(url.href);
            const html = await response.text();
            const doc = new DOMParser().parseFromString(html, "text/html");
            title = doc.title || url.hostname;
          } catch (e) {
            title = url.hostname;
          }

          const shortcuts = JSON.parse(
            localStorage.getItem("shortcuts") || "{}"
          );
          const faviconUrl = await getFaviconUrl(url.href);
          shortcuts[newPosition] = { title, url: url.href, faviconUrl };
          localStorage.setItem("shortcuts", JSON.stringify(shortcuts));

          reloadShortcuts(); // Instead of reloadWithTransition()
        } catch (e) {
          console.error("Invalid URL dropped:", e);
        }
        return;
      }      // If it's an internal drag (rearrangement)
      const activeTab = localStorage.getItem("activeTab") || "personal";
      const shortcuts = JSON.parse(localStorage.getItem(`shortcuts_${activeTab}`) || "{}");

      // Exchange shortcuts
      const temp = shortcuts[oldPosition];
      shortcuts[oldPosition] = shortcuts[newPosition];
      shortcuts[newPosition] = temp;

      // Save changes
      localStorage.setItem(`shortcuts_${currentActiveTab}`, JSON.stringify(shortcuts));
      localStorage.setItem("shortcuts", JSON.stringify(shortcuts));

      // Reload shortcuts
      reloadShortcuts();

      // Remove temporary style classes
      document.querySelectorAll('.shortcut-container a').forEach(el => {
        el.classList.remove('opacity-50');
      });
    }

    function handleDragStart(event, position) {
      event.dataTransfer.setData('text/plain', position);
      event.currentTarget.classList.add('opacity-50');
    } function generateAddRowButton() {
      return `
          <button
             onclick="addMoreShortcuts()"
             class="group p-6 backdrop-blur-xl bg-white/30 rounded-2xl shadow-lg hover:shadow-xl hover:bg-white/40 transition-all duration-300 border-2 border-dashed border-white/30 w-full"
             id="addRowButton">
            <div class="text-center">
              <div class="flex justify-center mb-2">
                <svg class="w-8 h-8 text-white/70" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                </svg>
              </div>              <div class="text-white/70 font-medium">Add more shortcuts</div>
            </div>
          </button>`;
    } function addMoreShortcuts() {
      const grid = document.getElementById("shortcutGrid");
      const currentCount =
        document.querySelectorAll("[data-position]").length;
      const addRowButton = document.getElementById("addRowButton");

      for (let i = currentCount; i < currentCount + 4; i++) {
        grid.insertBefore(
          document
            .createRange()
            .createContextualFragment(generateShortcut(i)),
          addRowButton
        );
      }

      localStorage.setItem("shortcutCount", currentCount + 4);
      reloadShortcuts(); // Au lieu de reloadWithTransition()
    } async function saveShortcut() {
      const modal = document.getElementById("configModal");
      const position = modal.getAttribute("data-position");
      const title = document.getElementById("shortcutTitle").value.trim();
      let url = document.getElementById("shortcutUrl").value.trim();

      console.debug('saveShortcut start', { position, title, url });

      if (!url.match(/^https?:\/\//i)) {
        url = "https://" + url;
      }

      try {
        const activeTab = localStorage.getItem("activeTab") || "personal";
        const currentView = localStorage.getItem('currentView');
        const currentFolderId = localStorage.getItem('currentFolderId');
        
        const faviconUrl = await getFaviconUrl(url);

        // Determine image choice
        const imageSource = document.querySelector('input[name="imageSource"]:checked')?.value || 'favicon';
        console.debug('selected imageSource:', imageSource);
        let imageUrl = null;
        if (imageSource === 'url') {
          const imgVal = document.getElementById('shortcutImageUrl')?.value.trim() || '';
          if (imgVal) {
            // check image loads
            const ok = await testImageUrl(imgVal).catch(() => false);
            if (!ok) {
              showNotification('Provided image URL failed to load. Please check the URL.');
              console.warn('Image URL failed to load:', imgVal);
              return; // abort save
            }
            imageUrl = imgVal;
          }
        } else if (imageSource === 'upload') {
          const fileInput = document.getElementById('shortcutImageFile');
          // If file was read earlier, it's stored on dataset
          const dataUrl = fileInput?.dataset?.dataUrl;
          console.debug('fileInput.dataset.dataUrl:', dataUrl);
          if (dataUrl) {
            imageUrl = dataUrl;
          } else if (fileInput && fileInput.files && fileInput.files[0]) {
            // fallback to read now
            imageUrl = await readFileAsDataURL(fileInput.files[0]);
            console.debug('read file to dataUrl length', imageUrl?.length || 0);
          }
        }

        const newEntry = { title, url, faviconUrl };
        if (imageUrl) newEntry.imageUrl = imageUrl;

        console.debug('saving shortcut entry', { position, newEntry });

        // Save to folder or main shortcuts
        if (currentView === 'folder' && currentFolderId) {
          const folders = JSON.parse(localStorage.getItem(`folders_${activeTab}`) || "{}");
          const folder = folders[currentFolderId];
          if (folder) {
            if (!folder.shortcuts) folder.shortcuts = {};
            folder.shortcuts[position] = newEntry;
            localStorage.setItem(`folders_${activeTab}`, JSON.stringify(folders));
          }
        } else {
          const shortcuts = JSON.parse(
            localStorage.getItem(`shortcuts_${activeTab}`) || "{}"
          );
          shortcuts[position] = newEntry;
          localStorage.setItem(
            `shortcuts_${activeTab}`,
            JSON.stringify(shortcuts)
          );
          localStorage.setItem("shortcuts", JSON.stringify(shortcuts));
        }

        closeConfigModal();
        reloadShortcuts(); // Instead of reloadWithTransition()
      } catch (e) {
        console.error("Error saving shortcut:", e);
      }
    } function openConfigModal(position, isEdit = false) {
      const modal = document.getElementById("configModal");
      const titleInput = document.getElementById("shortcutTitle");
      const urlInput = document.getElementById("shortcutUrl");
      const modalTitle = modal.querySelector("h2");

      modal.setAttribute("data-position", position);

      if (isEdit) {
        // Update modal title for editing
        modalTitle.textContent = "Edit shortcut";

        // Get current shortcut data for editing
        const activeTab = localStorage.getItem("activeTab") || "personal";
        const shortcuts = JSON.parse(localStorage.getItem(`shortcuts_${activeTab}`) || "{}");
        const shortcutData = shortcuts[position];
        console.debug('openConfigModal edit position:', position, 'shortcutData:', shortcutData);

        if (shortcutData) {
          titleInput.value = shortcutData.title || "";
          urlInput.value = shortcutData.url || "";

          // Prefill image selection
          const imageUrlInput = document.getElementById('shortcutImageUrl');
          const fileInput = document.getElementById('shortcutImageFile');
          const previewImg = document.getElementById('shortcutImagePreviewImg');

          if (shortcutData.imageUrl) {
            // If stored as dataURL or URL, use image option
            document.querySelector('input[name="imageSource"][value="url"]').checked = true;
            imageUrlInput.value = shortcutData.imageUrl;
            previewImg.src = shortcutData.imageUrl;
            previewImg.classList.remove('hidden');
            document.getElementById('imageUrlContainer').classList.remove('hidden');
            document.getElementById('imageUploadContainer').classList.add('hidden');
          } else {
            // default to favicon
            document.querySelector('input[name="imageSource"][value="favicon"]').checked = true;
            imageUrlInput.value = '';
            previewImg.src = '';
            previewImg.classList.add('hidden');
            document.getElementById('imageUrlContainer').classList.add('hidden');
            document.getElementById('imageUploadContainer').classList.add('hidden');
          }

          // Enable save button if both fields have values
          document.getElementById("saveButton").disabled = !shortcutData.title || !shortcutData.url;
        } else {
          titleInput.value = "";
          urlInput.value = "";
          document.getElementById('shortcutImageUrl').value = '';
          document.getElementById('shortcutImageFile').value = '';
          delete document.getElementById('shortcutImageFile').dataset.dataUrl;
          document.getElementById('shortcutImagePreviewImg').classList.add('hidden');
          document.querySelector('input[name="imageSource"][value="favicon"]').checked = true;
          document.getElementById('imageUrlContainer').classList.add('hidden');
          document.getElementById('imageUploadContainer').classList.add('hidden');
          document.getElementById("saveButton").disabled = true;
        }
      } else {
        // Update modal title for adding new shortcut
        modalTitle.textContent = "Add a shortcut";

        // Clear fields for new shortcut
        titleInput.value = "";
        urlInput.value = "";
        document.getElementById("saveButton").disabled = true;
      }

      modal.classList.remove("hidden");
      // Ensure image inputs visibility matches current selection
      toggleImageInputs();

      // Improved focus method with multiple attempts
      // First immediate attempt
      titleInput.focus();

      // Second attempt with a short delay
      setTimeout(() => {
        titleInput.focus();
      }, 50);

      // Third attempt with a longer delay to ensure the modal is fully rendered
      setTimeout(() => {
        titleInput.focus();
        // Move cursor to the end of text
        if (titleInput.value) {
          titleInput.selectionStart = titleInput.value.length;
          titleInput.selectionEnd = titleInput.value.length;
        }
      }, 150);
    }

    function closeConfigModal() {
      document.getElementById("configModal").classList.add("hidden");
      // Clear temporary image data and preview
      const fileInput = document.getElementById('shortcutImageFile');
      if (fileInput) {
        fileInput.value = '';
        delete fileInput.dataset.dataUrl;
      }
      const previewImg = document.getElementById('shortcutImagePreviewImg');
      if (previewImg) {
        previewImg.src = '';
        previewImg.classList.add('hidden');
      }
    }

    function editShortcut(position) {
      openConfigModal(position, true);
      closeContextMenu();
    }

    function pinToBothTabs(position) {
      const activeTab = localStorage.getItem("activeTab") || "personal";
      const currentShortcuts = JSON.parse(localStorage.getItem(`shortcuts_${activeTab}`) || "{}");

      // V√©rifier que le raccourci existe dans l'onglet actuel
      if (!currentShortcuts[position]) {
        console.error("Shortcut not found in current tab");
        closeContextMenu();
        return;
      }

      const shortcutData = currentShortcuts[position];

      // Sauvegarder dans l'onglet personnel
      const personalShortcuts = JSON.parse(localStorage.getItem("shortcuts_personal") || "{}");
      personalShortcuts[position] = { ...shortcutData };
      localStorage.setItem("shortcuts_personal", JSON.stringify(personalShortcuts));

      // Sauvegarder dans l'onglet professionnel
      const professionalShortcuts = JSON.parse(localStorage.getItem("shortcuts_professional") || "{}");
      professionalShortcuts[position] = { ...shortcutData };
      localStorage.setItem("shortcuts_professional", JSON.stringify(professionalShortcuts));

      // Mettre √† jour le localStorage principal avec l'onglet actuel
      localStorage.setItem("shortcuts", JSON.stringify(currentShortcuts));

      closeContextMenu();

      // Afficher une notification de succ√®s
      showNotification(`Shortcut "${shortcutData.title}" pinned to both tabs!`);

      // Recharger les raccourcis pour refl√©ter les changements
      reloadShortcuts();
    }

    function showNotification(message) {
      // Cr√©er un √©l√©ment de notification
      const notification = document.createElement('div');
      notification.className = 'fixed top-4 right-4 bg-green-500/90 backdrop-blur-xl text-white px-6 py-3 rounded-lg shadow-lg z-[9999] transition-all duration-300 transform translate-x-0';
      notification.textContent = message;

      // Ajouter au DOM
      document.body.appendChild(notification);

      // Animation d'entr√©e
      setTimeout(() => {
        notification.style.transform = 'translateX(0)';
      }, 10);

      // Supprimer apr√®s 3 secondes
      setTimeout(() => {
        notification.style.transform = 'translateX(100%)';
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 300);
      }, 3000);
    }

    function deleteShortcut() {
      const position = document
        .getElementById("contextMenu")
        .getAttribute("data-position");
      const activeTab = localStorage.getItem("activeTab") || "personal";

      // Get shortcuts from localStorage
      const shortcuts = JSON.parse(
        localStorage.getItem(`shortcuts_${activeTab}`) || "{}"
      );

      // Check if the shortcut is already empty (placeholder)
      const shortcutElement = document.querySelector(`a[data-position="${position}"]`);
      const iconContainer = shortcutElement?.querySelector(".shortcut-icon");
      const isEmpty = iconContainer?.getAttribute("data-empty") === "true";

      if (isEmpty) {
        // If it's already empty, remove it completely from the grid
        const currentShortcutCount = parseInt(localStorage.getItem("shortcutCount") || "8");
        const positionNum = parseInt(position);

        // Shift all shortcuts after this position down by one
        const newShortcuts = {};
        Object.keys(shortcuts).forEach(key => {
          const keyNum = parseInt(key);
          if (keyNum < positionNum) {
            newShortcuts[key] = shortcuts[key];
          } else if (keyNum > positionNum) {
            newShortcuts[(keyNum - 1).toString()] = shortcuts[key];
          }
        });

        // Reduce shortcut count by 1
        localStorage.setItem("shortcutCount", (currentShortcutCount - 1).toString());
        localStorage.setItem(`shortcuts_${activeTab}`, JSON.stringify(newShortcuts));
        localStorage.setItem("shortcuts", JSON.stringify(newShortcuts));
      } else {
        // If it has content, just clear it (make it a placeholder)
        delete shortcuts[position];
        localStorage.setItem(`shortcuts_${activeTab}`, JSON.stringify(shortcuts));
        localStorage.setItem("shortcuts", JSON.stringify(shortcuts));
      }

      closeContextMenu();

      // Reload shortcuts to update the display
      reloadShortcuts();
    }

    document.addEventListener("DOMContentLoaded", () => {
      let allowHardFocus = true;

      function focusSearch() {
        const searchInput = document.getElementById("searchInput");
        if (searchInput && allowHardFocus) {
          searchInput.focus();
        }
      }

      // Focus initial et pendant les premi√®res secondes
      focusSearch();
      setTimeout(focusSearch, 100);

      // D√©sactiver le hard focus apr√®s 3 secondes
      setTimeout(() => {
        allowHardFocus = false;
      }, 3000);

      // Garder seulement les √©v√©nements essentiels apr√®s la p√©riode initiale
      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "visible" && allowHardFocus) {
          focusSearch();
        }
      });

      window.addEventListener("focus", () => {
        if (allowHardFocus) {
          focusSearch();
        }
      });

      const grid = document.getElementById("shortcutGrid");
      const shortcuts = JSON.parse(localStorage.getItem("shortcuts") || "{}");
      const activeTab = localStorage.getItem("activeTab") || "personal";
      const folders = JSON.parse(localStorage.getItem(`folders_${activeTab}`) || "{}");
      const shortcutCount = parseInt(
        localStorage.getItem("shortcutCount") || "8"
      );

      for (let i = 0; i < shortcutCount; i++) {
        grid.innerHTML += generateShortcut(i);
      }

      Object.entries(shortcuts).forEach(([position, data]) => {
        const shortcut = document.querySelector(
          `[data-position="${position}"]`
        );
        if (shortcut) {
          shortcut.href = data.url;
          shortcut.onclick = (e) => {
            e.preventDefault();
            performSearchRedirect(data.url, data.title || data.url, 5);
          };
          shortcut.querySelector(".shortcut-title").textContent = data.title;
          const iconContainer = shortcut.querySelector(".shortcut-icon");
          iconContainer.removeAttribute("data-empty");
          const imgSrc = data.imageUrl || data.iconURL || data.faviconUrl || '';
          iconContainer.innerHTML = `
              <img src="${imgSrc}" 
                 class="w-8 h-8 aspect-square mt-2 mb-2 group-hover:scale-120 transition-transform duration-300 object-cover rounded" 
                 alt="${data.title}" 
                 onerror="this.src='data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 100 100\'><text y=\'.9em\' font-size=\'90\'>üåê</text></svg>\'">`;
        }
      });

      // Load and display folders
      Object.values(folders).forEach(folder => {
        grid.innerHTML += generateFolderShortcut(folder);
      });

      grid.innerHTML += generateAddRowButton();
      grid.innerHTML += generateCreateFolderButton();

      const searchInput = document.getElementById("searchInput");
      const searchButton = document.querySelector(".absolute svg");

      // Initialize search counter display
      const searchCounterEl = document.getElementById('searchCounter');
      if (searchCounterEl && typeof formatSearchCounter === 'function') {
        searchCounterEl.textContent = formatSearchCounter(getSearchCounterSeconds());
      }

      if (searchInput) searchInput.addEventListener("keydown", handleSearch);
      if (searchButton) searchButton.addEventListener("click", handleSearch);

      const menuButton = document.getElementById("mobileMenuButton");
      const sidebar = document.getElementById("sidebar");

      if (menuButton) {
        menuButton.addEventListener("click", () => {
          sidebar.classList.toggle("mobile-hidden");
          menuButton.classList.toggle("open");
        });
      }

      // Tab morphing indicator: create element and update position
      function createTabIndicator() {
        const sidebarEl = document.getElementById('sidebar');
        if (!sidebarEl) return;
        let ind = document.getElementById('tabIndicator');
        if (!ind) {
          ind = document.createElement('div');
          ind.id = 'tabIndicator';
          sidebarEl.appendChild(ind);
        }
        // Position initially to the active tab
        const active = localStorage.getItem('activeTab') || 'personal';
        updateTabIndicator(active, true);
        window.addEventListener('resize', () => updateTabIndicator(localStorage.getItem('activeTab') || 'personal'));
      }

      function updateTabIndicator(tab, skipAnimation) {
        const sidebarEl = document.getElementById('sidebar');
        const ind = document.getElementById('tabIndicator');
        const target = document.getElementById(tab + 'Tab');
        if (!sidebarEl || !ind || !target) return;
        const sidebarRect = sidebarEl.getBoundingClientRect();
        const rect = target.getBoundingClientRect();
        const left = rect.left - sidebarRect.left;
        const top = rect.top - sidebarRect.top;
        const radius = Math.min(24, rect.height / 2) + 'px';
        if (skipAnimation) {
          ind.style.transition = 'none';
          ind.style.left = left + 'px';
          ind.style.top = top + 'px';
          ind.style.width = rect.width + 'px';
          ind.style.height = rect.height + 'px';
          ind.style.borderRadius = radius;
          requestAnimationFrame(() => ind.style.transition = '');
        } else {
          ind.style.left = left + 'px';
          ind.style.top = top + 'px';
          ind.style.width = rect.width + 'px';
          ind.style.height = rect.height + 'px';
          ind.style.borderRadius = radius;
          // subtle squash to emphasize morph
          ind.style.transform = 'scaleX(0.995) scaleY(1.02)';
          clearTimeout(ind._morphTimeout);
          ind._morphTimeout = setTimeout(() => {
            ind.style.transform = '';
          }, 150);
        }
      }

      // Expose globally so other functions can call it
      window.updateTabIndicator = updateTabIndicator;
      createTabIndicator();

      const searchIcon = document.querySelector(".absolute svg");
      const currentSearch = document.getElementById("currentSearch");

      if (searchInput && searchIcon && currentSearch) {
        searchInput.addEventListener("keydown", handleSearch);
        searchIcon.addEventListener("click", handleSearch);

        // Portal the dropdown to document.body to escape ancestor stacking contexts
        const dropdown = document.getElementById("searchEngineDropdown");
        const portalState = { moved: false, originalParent: null, nextSibling: null };

        function positionDropdown() {
          if (!dropdown) return;
          const btn = document.getElementById('currentSearch');
          const rect = btn.getBoundingClientRect();
          dropdown.style.position = 'absolute';
          dropdown.style.left = (rect.left + window.scrollX) + 'px';
          dropdown.style.top = (rect.bottom + window.scrollY + 6) + 'px';
          // ensure dropdown appears above other content
          dropdown.style.zIndex = 2147483647;
        }

        function openSearchDropdown() {
          if (!dropdown) return;
          if (!portalState.moved) {
            portalState.originalParent = dropdown.parentElement;
            portalState.nextSibling = dropdown.nextSibling;
            document.body.appendChild(dropdown);
            portalState.moved = true;
          }
          positionDropdown();
          dropdown.classList.remove('hidden');
          window.addEventListener('resize', positionDropdown);
          window.addEventListener('scroll', positionDropdown, true);
        }

        function closeSearchDropdown() {
          if (!dropdown) return;
          dropdown.classList.add('hidden');
          window.removeEventListener('resize', positionDropdown);
          window.removeEventListener('scroll', positionDropdown, true);
          if (portalState.moved) {
            // move back into original container to preserve DOM order
            if (portalState.nextSibling) portalState.originalParent.insertBefore(dropdown, portalState.nextSibling);
            else portalState.originalParent.appendChild(dropdown);
            portalState.moved = false;
            dropdown.style.position = '';
            dropdown.style.left = '';
            dropdown.style.top = '';
            dropdown.style.zIndex = '';
          }
        }

        currentSearch.addEventListener("click", (e) => {
          e.stopPropagation();
          if (!dropdown) return;
          if (dropdown.classList.contains('hidden')) openSearchDropdown();
          else closeSearchDropdown();
        });
      }

      document.querySelectorAll(".search-option").forEach((option) => {
        option.addEventListener("click", (e) => {
          const value = e.currentTarget.dataset.value;
          const img = e.currentTarget.querySelector("img");
          const searchBtn = document.querySelector("#currentSearch img");

          if (searchBtn && img) {
            searchBtn.src = img.src;
          }

          const searchEngine = document.getElementById("searchEngine");
          if (searchEngine) {
            searchEngine.value = value;
          }

          const searchInput = document.getElementById("searchInput");
          if (searchInput) {
            const currentText = searchInput.value.trim();
            let newText = currentText;

            if (currentText.startsWith("/")) {
              const parts = currentText.substring(1).split(" ");
              const possibleCommand = parts[0].toLowerCase();
              const validCommands = [
                "g",
                "yt",
                "gh",
                "w",
                "r",
                "so",
                "a",
                "n",
                "sp",
                "tw",
                "ig",
                "maps",
                "i",
              ];
              if (validCommands.includes(possibleCommand)) {
                newText = parts.slice(1).join(" ");
              }
            }

            searchInput.value =
              newText.length > 0 ? `/${value} ${newText}` : `/${value} `;
            searchInput.focus();
            searchInput.selectionStart = searchInput.value.length;
            searchInput.selectionEnd = searchInput.value.length;
          }

          const dropdown = document.getElementById("searchEngineDropdown");
          if (dropdown) {
            dropdown.classList.add("hidden");
          }
        });
      });

      // Close dropdown if clicked elsewhere (ignore clicks inside dropdown or trigger)
      document.addEventListener("click", (e) => {
        const dropdown = document.getElementById("searchEngineDropdown");
        const trigger = document.getElementById('currentSearch');
        if (!dropdown) return;
        if (e.target.closest('#searchEngineDropdown')) return;
        if (e.target.closest('#currentSearch')) return;
        dropdown.classList.add('hidden');
      });

      switchTab(activeTab);
    });

    // Search counter helpers: stored in seconds
    function formatSearchCounter(seconds) {
      if (!seconds || seconds < 60) return `${seconds || 0}s`;
      if (seconds < 3600) return `${Math.floor(seconds / 60)}m`;
      return `${Math.floor(seconds / 3600)}h`;
    }

    function getSearchCounterSeconds() {
      return parseInt(localStorage.getItem('searchCounterSeconds') || '0', 10);
    }

    function setSearchCounterSeconds(sec) {
      localStorage.setItem('searchCounterSeconds', String(Math.max(0, Math.floor(sec || 0))));
    }

    function incrementSearchCounterSeconds(by) {
      const next = getSearchCounterSeconds() + (parseInt(by, 10) || 0);
      setSearchCounterSeconds(next);
      const el = document.getElementById('searchCounter');
      if (el) el.textContent = formatSearchCounter(next);
      return next;
    }

    function performSearchRedirect(url, query) {
      const updated = incrementSearchCounterSeconds(10);
      try {
        const searches = JSON.parse(localStorage.getItem('searches') || '[]');
        searches.push({ query: query || '', time: Date.now(), counterSeconds: updated });
        localStorage.setItem('searches', JSON.stringify(searches));
      } catch (e) {
        localStorage.setItem('searches', JSON.stringify([{ query: query || '', time: Date.now(), counterSeconds: updated }]));
      }
      setTimeout(() => { window.location.href = url; }, 60);
    }

    function handleSearch(event) {
      if (
        (event.type === "keydown" && event.key === "Enter") ||
        event.type === "click"
      ) {
        event.preventDefault();

        let query = document.getElementById("searchInput").value.trim();
        let selectedEngine = document.getElementById("searchEngine").value;

        const searchEngines = {
          g: "https://www.google.com/search?q=",
          yt: "https://www.youtube.com/results?search_query=",
          gh: "https://github.com/search?q=",
          w: "https://en.wikipedia.org/wiki/Special:Search?search=",
          r: "https://www.reddit.com/search/?q=",
          so: "https://stackoverflow.com/search?q=",
          a: "https://www.amazon.fr/s?k=",
          n: "https://www.netflix.com/search?q=",
          sp: "https://open.spotify.com/search/results",
          tw: "https://twitter.com/search?q=",
          ig: "https://www.instagram.com/explore/tags/",
          maps: "https://www.google.com/maps/search/",
          i: "https://www.google.com/images?q=",
          ddg: "https://duckduckgo.com/?q=",
          px: "https://www.perplexity.ai/search?q=",
          ph: "https://fr.pornhub.com/video/search?search=",
        };      // Check if we should suggest an autocorrection
        // If the query ends with a question mark, perform the search directly on Perplexity
        if (query.endsWith('?')) {
          const cleaned = query.slice(0, -1).trim();
          if (cleaned.length > 0) {
            performSearchRedirect(searchEngines['px'] + encodeURIComponent(cleaned), cleaned);
            return; // stop further processing
          }
        }

        if (shouldSuggestAutocorrection(query)) {
          // Display the autocorrection popup
          showAutocorrectionModal(query);
          return; // Stop execution here
        }

        if (query.startsWith("/")) {
          const parts = query.substring(1).split(" ");
          if (parts.length > 1) {
            const possibleCommand = parts[0].toLowerCase();
            if (searchEngines[possibleCommand]) {
              selectedEngine = possibleCommand;
              query = parts.slice(1).join(" ");
            }
          }
        }

        const searchUrl = searchEngines[selectedEngine] || searchEngines["g"];
        if (query) {
          performSearchRedirect(searchUrl + encodeURIComponent(query), query);
        }
      }
    }    // Function to check if we should suggest an autocorrection
    function shouldSuggestAutocorrection(query) {
      // Only suggest autocorrection IF the query starts with ":"
      if (!query.startsWith(":")) {
        return false;
      }
      // List of valid commands
      const validSearchCommands = {
        "g": "Google",
        "yt": "YouTube",
        "gh": "GitHub",
        "w": "Wikipedia",
        "r": "Reddit",
        "so": "Stack Overflow",
        "a": "Amazon",
        "n": "Netflix",
        "sp": "Spotify",
        "tw": "Twitter",
        "ig": "Instagram",
        "maps": "Google Maps",
        "i": "Google Images",
        "ddg": "DuckDuckGo",
        "px": "Perplexity AI"
      };
      // Extract the part after ":" (until the first space or end of string)
      const commandPart = query.substring(1).split(" ")[0].toLowerCase();
      // Check if this part matches a valid command
      return Object.keys(validSearchCommands).includes(commandPart);
    }    // Function to display the autocorrection modal
    function showAutocorrectionModal(originalQuery) {
      const correctedQuery = convertToSearchCommand(originalQuery);
      document.getElementById("originalQuery").textContent = originalQuery;
      document.getElementById("correctedQuery").textContent = correctedQuery;
      document.getElementById("autocorrectionModal").classList.remove("hidden");
      // Store queries for later use
      document.getElementById("autocorrectionModal").setAttribute("data-original-query", originalQuery);
      document.getElementById("autocorrectionModal").setAttribute("data-corrected-query", correctedQuery);
      // Add listener for Shift+Y and Shift+N
      function autocorrectKeyListener(e) {
        if (e.shiftKey && (e.key === 'Y' || e.key === 'y')) {
          executeCorrectedSearch();
          document.removeEventListener('keydown', autocorrectKeyListener);
        } else if (e.shiftKey && (e.key === 'N' || e.key === 'n')) {
          executeOriginalSearch();
          document.removeEventListener('keydown', autocorrectKeyListener);
        }
      }
      document.addEventListener('keydown', autocorrectKeyListener);
    }    // Function to convert a query to appropriate search
    function convertToSearchCommand(query) {
      // Complete list of valid search commands
      const validSearchCommands = {
        "g": "Google",
        "yt": "YouTube",
        "gh": "GitHub",
        "w": "Wikipedia",
        "r": "Reddit",
        "so": "Stack Overflow",
        "a": "Amazon",
        "n": "Netflix",
        "sp": "Spotify",
        "tw": "Twitter",
        "ig": "Instagram",
        "maps": "Google Maps",
        "i": "Google Images",
        "ddg": "DuckDuckGo",
        "px": "Perplexity AI"
      };

      // Get the currently selected engine
      const currentEngine = document.getElementById("searchEngine").value;
      const currentEngineName = validSearchCommands[currentEngine] || "Google";

      // Remove the ":" at the beginning if present
      if (query.startsWith(":")) {
        query = query.substring(1);
      }

      // Convert to lowercase
      const lowercaseQuery = query.toLowerCase().trim();

      // Detect if the first word is a search command
      let detectedCommand = null;
      let searchTerms = lowercaseQuery;

      // Check the first word (or letter)
      const firstSpace = lowercaseQuery.indexOf(" ");
      if (firstSpace > 0) {
        const possibleCommand = lowercaseQuery.substring(0, firstSpace).toLowerCase();

        // Strictly check if the command is in our list of valid commands
        if (Object.keys(validSearchCommands).includes(possibleCommand)) {
          detectedCommand = possibleCommand;
          searchTerms = lowercaseQuery.substring(firstSpace + 1);
        }
        // Don't try to interpret any text as a command
      } else if (Object.keys(validSearchCommands).includes(lowercaseQuery)) {
        // If the entire query is exactly a valid command
        detectedCommand = lowercaseQuery;
        searchTerms = "";
      }

      // If a valid command was detected, use it
      if (detectedCommand) {
        document.getElementById("autocorrectionModal").querySelector("p.mt-2").textContent =
          `The search will be performed on ${validSearchCommands[detectedCommand]}`;
        return `/${detectedCommand} ${searchTerms}`.trim();
      }

      // By default, use the currently selected search engine with the entire query
      document.getElementById("autocorrectionModal").querySelector("p.mt-2").textContent =
        `The search will be performed on ${currentEngineName}`;
      return `/${currentEngine} ${lowercaseQuery}`;
    }    // Function to execute the original search
    function executeOriginalSearch() {
      const originalQuery = document.getElementById("autocorrectionModal").getAttribute("data-original-query");
      document.getElementById("autocorrectionModal").classList.add("hidden");

      // Get the currently selected search engine
      let selectedEngine = document.getElementById("searchEngine").value;

      // Directly extract search URLs to avoid going through the autocorrection process again
      const searchEngines = {
        g: "https://www.google.com/search?q=",
        yt: "https://www.youtube.com/results?search_query=",
        gh: "https://github.com/search?q=",
        w: "https://en.wikipedia.org/wiki/Special:Search?search=",
        r: "https://www.reddit.com/search/?q=",
        so: "https://stackoverflow.com/search?q=",
        a: "https://www.amazon.fr/s?k=",
        n: "https://www.netflix.com/search?q=",
        sp: "https://open.spotify.com/search/results",
        tw: "https://twitter.com/search?q=",
        ig: "https://www.instagram.com/explore/tags/",
        maps: "https://www.google.com/maps/search/",
        i: "https://www.google.com/images?q=",
        ddg: "https://duckduckgo.com/?q=",
        px: "https://www.perplexity.ai/search?q=",
        ph: "https://fr.pornhub.com/video/search?search=",
      };

      // Check if the query starts with a specific command
      if (originalQuery.startsWith("/")) {
        const parts = originalQuery.substring(1).split(" ");
        if (parts.length > 0 && searchEngines[parts[0].toLowerCase()]) {
          selectedEngine = parts[0].toLowerCase();
          const query = parts.slice(1).join(" ");
          performSearchRedirect(searchEngines[selectedEngine] + encodeURIComponent(query), query);
          return;
        }
      }

      // If no specific command, use the original query directly
      performSearchRedirect(searchEngines[selectedEngine] + encodeURIComponent(originalQuery), originalQuery);
    }    // Function to execute the corrected search
    function executeCorrectedSearch() {
      const correctedQuery = document.getElementById("autocorrectionModal").getAttribute("data-corrected-query");
      document.getElementById("searchInput").value = correctedQuery;
      document.getElementById("autocorrectionModal").classList.add("hidden");

      // Extract the search command and search terms
      if (correctedQuery.startsWith('/')) {
        const parts = correctedQuery.substring(1).split(' ');
        const command = parts[0].toLowerCase();
        const searchTerms = parts.slice(1).join(' ');

        const searchEngines = {
          g: "https://www.google.com/search?q=",
          yt: "https://www.youtube.com/results?search_query=",
          gh: "https://github.com/search?q=",
          w: "https://en.wikipedia.org/wiki/Special:Search?search=",
          r: "https://www.reddit.com/search/?q=",
          so: "https://stackoverflow.com/search?q=",
          a: "https://www.amazon.fr/s?k=",
          n: "https://www.netflix.com/search?q=",
          sp: "https://open.spotify.com/search/results",
          tw: "https://twitter.com/search?q=",
          ig: "https://www.instagram.com/explore/tags/",
          maps: "https://www.google.com/maps/search/",
          i: "https://www.google.com/images?q=",
          ddg: "https://duckduckgo.com/?q=",
          px: "https://www.perplexity.ai/search?q=",
        };

        // If the command is valid, execute the search directly
        if (searchEngines[command]) {
          performSearchRedirect(searchEngines[command] + encodeURIComponent(searchTerms), searchTerms);
          return;
        }
      }

      // Fallback: execute the search via handleSearch
      handleSearch({ type: "click" });
    }

    function reloadShortcuts() {
      const grid = document.getElementById("shortcutGrid");
      const activeTab = localStorage.getItem("activeTab") || "personal";
      
      // Check if we're in a folder view
      const currentView = localStorage.getItem('currentView');
      const currentFolderId = localStorage.getItem('currentFolderId');
      
      if (currentView === 'folder' && currentFolderId) {
        const folders = JSON.parse(localStorage.getItem(`folders_${activeTab}`) || "{}");
        const folder = folders[currentFolderId];
        if (folder) {
          displayFolderView(folder);
          return;
        }
      }
      
      // Normal view
      const shortcuts = JSON.parse(localStorage.getItem(`shortcuts_${activeTab}`) || "{}");
      const folders = JSON.parse(localStorage.getItem(`folders_${activeTab}`) || "{}");

      // Supprimer tous les raccourcis existants mais garder le bouton d'ajout
      const addRowButton = document.getElementById("addRowButton");
      grid.innerHTML = '';

      // D√©terminer le nombre r√©el de raccourcis √† afficher
      const shortcutCount = parseInt(localStorage.getItem("shortcutCount") || "8");

      // Recr√©er les raccourcis
      for (let i = 0; i < shortcutCount; i++) {
        grid.innerHTML += generateShortcut(i);
      }

      // Mettre √† jour l'apparence des raccourcis avec les donn√©es stock√©es
      for (const position in shortcuts) {
        const shortcutData = shortcuts[position];
        const shortcutElement = document.querySelector(`a[data-position="${position}"]`);

        if (shortcutElement && shortcutData) {
          // Mettre √† jour l'apparence du raccourci
          const iconElement = shortcutElement.querySelector('.shortcut-icon');
          const titleElement = shortcutElement.querySelector('.shortcut-title');

          const src = shortcutData.imageUrl || shortcutData.iconURL || shortcutData.faviconUrl || null;
          console.debug('reloadShortcuts applying src for position', position, src ? src.substring(0,100) : null);
          if (src) {
            iconElement.innerHTML = `<img src="${src}" alt="${shortcutData.title}" class="mx-auto h-12 w-12 min-w-[3rem] min-h-[3rem] max-w-[3rem] max-h-[3rem] rounded object-cover" style="aspect-ratio: 1/1;" onerror="this.src='data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 100 100\'><text y=\'.9em\' font-size=\'90\'>üåê</text></svg>'">`;
            iconElement.setAttribute('data-empty', 'false');
          }

          if (shortcutData.title) {
            titleElement.textContent = shortcutData.title;
          }

          if (shortcutData.url) {
            shortcutElement.href = shortcutData.url;
          }
        }
      }
      
      // Add folders to grid
      Object.values(folders).forEach(folder => {
        grid.innerHTML += generateFolderShortcut(folder);
      });

      // Remettre le bouton d'ajout
      grid.innerHTML += generateAddRowButton();
      
      // Add create folder button
      grid.innerHTML += generateCreateFolderButton();

      // Mettre √† jour les raccourcis avec leurs donn√©es
      Object.entries(shortcuts).forEach(([position, data]) => {
        const shortcut = document.querySelector(`[data-position="${position}"]`);
        if (shortcut) {
          shortcut.href = data.url;
          shortcut.onclick = (e) => {
            e.preventDefault();
            performSearchRedirect(data.url, data.title || data.url, 5);
          };
          shortcut.querySelector(".shortcut-title").textContent = data.title;
          const iconContainer = shortcut.querySelector(".shortcut-icon");
          iconContainer.removeAttribute("data-empty");
          const imgSrc = data.imageUrl || data.iconURL || data.faviconUrl || '';
          iconContainer.innerHTML = `
              <img src="${imgSrc}" 
                 class="w-8 h-8 min-w-[2rem] min-h-[2rem] max-w-[2rem] max-h-[2rem] mt-2 mb-2 group-hover:scale-120 transition-transform duration-300 object-cover rounded" 
                 style="aspect-ratio: 1/1;"
                 alt="${data.title}" 
                 onerror="this.src='data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 100 100\'><text y=\'.9em\' font-size=\'90\'>üåê</text></svg>\'">`;
        }
      });
    }

    function switchTab(tab) {
      // Don't do anything if we're already on the selected tab
      if (localStorage.getItem("activeTab") === tab) {
        return;
      }

      // Update visual interface
      document.getElementById("personalTab").classList.toggle("bg-white/60", tab === "personal");
      document.getElementById("professionalTab").classList.toggle("bg-white/60", tab === "professional");

      // Move the morphing indicator
      if (typeof window.updateTabIndicator === 'function') {
        window.updateTabIndicator(tab);
      }

      // Save active tab
      localStorage.setItem("activeTab", tab);

      // Load corresponding shortcuts
      const shortcuts = JSON.parse(localStorage.getItem(`shortcuts_${tab}`) || "{}");
      localStorage.setItem("shortcuts", JSON.stringify(shortcuts));

      // Reload shortcuts
      reloadShortcuts();

      // Update widget order based on pins for the new tab
      const orderedWidgets = getPinnedWidgetOrder();
      const currentWidget = getCurrentWidget();
      const newIndex = orderedWidgets.findIndex(widget => widget.id === currentWidget.id);

      // Update the widgets array and current index
      widgets.splice(0, widgets.length, ...orderedWidgets);
      currentWidgetIndex = newIndex >= 0 ? newIndex : 0;

      // Update display
      updateWidgetDisplay();
      updateWidgetIndicators();
    }

    // Export/Import Functions
    function exportShortcuts() {
      try {
        // R√©cup√©rer toutes les donn√©es de raccourcis
        const personalShortcuts = JSON.parse(localStorage.getItem("shortcuts_personal") || "{}");
        const professionalShortcuts = JSON.parse(localStorage.getItem("shortcuts_professional") || "{}");
        const shortcutCount = localStorage.getItem("shortcutCount") || "8";

        // R√©cup√©rer les donn√©es de pins de widgets
        const personalWidgetPins = JSON.parse(localStorage.getItem("widgetPins_personal") || "{}");
        const professionalWidgetPins = JSON.parse(localStorage.getItem("widgetPins_professional") || "{}");

        // Cr√©er l'objet d'export
        const exportData = {
          version: "2.0",
          exportDate: new Date().toISOString(),
          shortcutCount: parseInt(shortcutCount),
          personal: personalShortcuts,
          professional: professionalShortcuts,
          widgetPins: {
            personal: personalWidgetPins,
            professional: professionalWidgetPins
          }
        };

        // Cr√©er le fichier JSON
        const dataStr = JSON.stringify(exportData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });

        // Cr√©er le lien de t√©l√©chargement
        const link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = `newtab-shortcuts-${new Date().toISOString().split('T')[0]}.json`;

        // D√©clencher le t√©l√©chargement
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        // Notification de succ√®s
        showNotification('Shortcuts and widget preferences exported successfully!');

      } catch (error) {
        console.error('Export error:', error);
        showNotification('Export failed. Please try again.');
      }
    }

    function showImportModal() {
      document.getElementById('importModal').classList.remove('hidden');
    }

    function closeImportModal() {
      document.getElementById('importModal').classList.add('hidden');
    }

    function triggerFileImport() {
      document.getElementById('importFileInput').click();
    }

    function handleFileImport(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          const importData = JSON.parse(e.target.result);

          // Validation basique
          if (!importData.personal && !importData.professional) {
            throw new Error('Invalid file format');
          }

          // Demander confirmation √† l'utilisateur
          if (confirm('This will replace your current shortcuts. Are you sure?')) {
            importShortcuts(importData);
          }

        } catch (error) {
          console.error('Import error:', error);
          showNotification('Import failed. Please check your file format.');
        }
      };

      reader.readAsText(file);
      // Reset input pour permettre de r√©importer le m√™me fichier
      event.target.value = '';
    }

    function importShortcuts(data) {
      try {
        // Importer les raccourcis personnels
        if (data.personal) {
          localStorage.setItem("shortcuts_personal", JSON.stringify(data.personal));
        }

        // Importer les raccourcis professionnels
        if (data.professional) {
          localStorage.setItem("shortcuts_professional", JSON.stringify(data.professional));
        }

        // Importer les pr√©f√©rences de widgets si disponibles
        if (data.widgetPins) {
          if (data.widgetPins.personal) {
            localStorage.setItem("widgetPins_personal", JSON.stringify(data.widgetPins.personal));
          }
          if (data.widgetPins.professional) {
            localStorage.setItem("widgetPins_professional", JSON.stringify(data.widgetPins.professional));
          }
        }

        // Mettre √† jour le count si disponible
        if (data.shortcutCount) {
          localStorage.setItem("shortcutCount", data.shortcutCount.toString());
        }

        // Mettre √† jour l'onglet actuel
        const activeTab = localStorage.getItem("activeTab") || "personal";
        const currentShortcuts = JSON.parse(localStorage.getItem(`shortcuts_${activeTab}`) || "{}");
        localStorage.setItem("shortcuts", JSON.stringify(currentShortcuts));

        // Fermer le modal
        closeImportModal();

        // Recharger l'affichage et r√©organiser les widgets
        reloadShortcuts();

        // Update widget order based on imported pins
        const orderedWidgets = getPinnedWidgetOrder();
        widgets.splice(0, widgets.length, ...orderedWidgets);
        currentWidgetIndex = 0;
        updateWidgetDisplay();
        updateWidgetIndicators();

        // Notification de succ√®s
        showNotification('Shortcuts and widget preferences imported successfully!');

      } catch (error) {
        console.error('Import processing error:', error);
        showNotification('Import failed during processing.');
      }
    }

    // Validation function for the configuration modal
    function validateForm() {
      const title = document.getElementById("shortcutTitle");
      const url = document.getElementById("shortcutUrl");
      const saveButton = document.getElementById("saveButton");

      if (!title || !url || !saveButton) return;

      const titleValue = title.value.trim();
      const urlValue = url.value.trim();

      const isTitleValid = titleValue.length > 0;
      const isUrlValid = urlValue.length > 0;

      // Image validation when user explicitly selects it
      const imageSource = document.querySelector('input[name="imageSource"]:checked')?.value || 'favicon';
      let isImageValid = true;
      if (imageSource === 'url') {
        const imgUrl = document.getElementById('shortcutImageUrl')?.value.trim() || '';
        isImageValid = imgUrl.length > 0;
      } else if (imageSource === 'upload') {
        const fileInput = document.getElementById('shortcutImageFile');
        isImageValid = fileInput && fileInput.files && fileInput.files.length > 0;
      }

      saveButton.disabled = !isTitleValid || !isUrlValid || !isImageValid;
    }

    // Helpers for image inputs and preview
    function toggleImageInputs() {
      const imageSource = document.querySelector('input[name="imageSource"]:checked')?.value || 'favicon';
      document.getElementById('imageUrlContainer').classList.toggle('hidden', imageSource !== 'url');
      document.getElementById('imageUploadContainer').classList.toggle('hidden', imageSource !== 'upload');
      updateImagePreview();
      validateForm();
    }

    function handleImageFileSelect(e) {
      const file = e.target.files && e.target.files[0];
      console.debug('handleImageFileSelect file:', file);
      if (!file) return;
      // Simple file size guard (500 KB)
      const maxBytes = 500 * 1024;
      if (file.size > maxBytes) {
        showNotification('File too large. Please use an image smaller than 500 KB.');
        e.target.value = '';
        return;
      }
      readFileAsDataURL(file).then((dataUrl) => {
        console.debug('file read as dataURL length:', dataUrl?.length || 0);
        const img = document.getElementById('shortcutImagePreviewImg');
        img.src = dataUrl;
        img.classList.remove('hidden');
        // store temporarily on the input element so saveShortcut can read it
        document.getElementById('shortcutImageFile').dataset.dataUrl = dataUrl;
        validateForm();
      }).catch(err => console.error('Image file read error:', err));
    }

    function updateImagePreview() {
      const imageSource = document.querySelector('input[name="imageSource"]:checked')?.value || 'favicon';
      const previewImg = document.getElementById('shortcutImagePreviewImg');
      console.debug('updateImagePreview imageSource:', imageSource);
      if (imageSource === 'url') {
        const url = document.getElementById('shortcutImageUrl')?.value.trim() || '';
        console.debug('preview URL:', url);
        if (url) {
          previewImg.src = url;
          previewImg.classList.remove('hidden');
        } else {
          previewImg.src = '';
          previewImg.classList.add('hidden');
        }
      } else if (imageSource === 'upload') {
        const fileInput = document.getElementById('shortcutImageFile');
        const dataUrl = fileInput?.dataset?.dataUrl || '';
        console.debug('preview dataUrl present:', !!dataUrl);
        if (dataUrl) {
          previewImg.src = dataUrl;
          previewImg.classList.remove('hidden');
        } else {
          previewImg.src = '';
          previewImg.classList.add('hidden');
        }
      } else {
        // favicon selected
        previewImg.src = '';
        previewImg.classList.add('hidden');
      }
    }

    function readFileAsDataURL(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    // Validate whether an image URL actually loads
    function testImageUrl(url, timeout = 5000) {
      return new Promise((resolve) => {
        try {
          const img = new Image();
          let timedOut = false;
          const t = setTimeout(() => {
            timedOut = true;
            img.src = '';
            resolve(false);
          }, timeout);
          img.onload = () => {
            if (!timedOut) {
              clearTimeout(t);
              resolve(true);
            }
          };
          img.onerror = () => {
            if (!timedOut) {
              clearTimeout(t);
              resolve(false);
            }
          };
          img.src = url;
        } catch (e) {
          resolve(false);
        }
      });
    }

    // ==================== SETTINGS MENU FUNCTIONALITY ====================

    function toggleSettingsMenu() {
      const menu = document.getElementById('settingsMenu');
      menu.classList.toggle('hidden');
    }

    function showAboutModal() {
      const modal = document.createElement('div');
      modal.className = 'fixed inset-0 bg-black/40 backdrop-blur-xl flex items-center justify-center z-50';
      modal.innerHTML = `
        <div class="bg-white/95 rounded-2xl p-6 w-[400px] shadow-2xl backdrop-blur-xl">
          <h2 class="text-2xl font-bold mb-4 text-gray-900">About New Tab</h2>
          <div class="text-gray-700 space-y-3">
            <p><strong>Version:</strong> 2.0</p>
            <p><strong>Developer:</strong> Kilian Barbier</p>
            <p><strong>Features:</strong></p>
            <ul class="list-disc list-inside ml-4 space-y-1">
              <li>Personal & Professional shortcuts</li>
              <li>Weather widget</li>
              <li>Notes widget</li>
              <li>Pomodoro timer</li>
              <li>Export/Import functionality</li>
            </ul>
          </div>
          <div class="flex justify-end gap-3 mt-6">
            <button onclick="this.closest('.fixed').remove()" 
                    class="px-4 py-2 bg-blue-500/80 hover:bg-blue-600/80 rounded-lg text-white">
              Close
            </button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);

      // Close on click outside
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.remove();
        }
      });
    }

    /* Background customization functions */
    function openBackgroundModal() {
      const modal = document.getElementById('backgroundCustomizationModal');
      if (modal) modal.classList.remove('hidden');
      // Load current settings into modal
      loadBackgroundSettings();
    }

    function closeBackgroundModal() {
      const modal = document.getElementById('backgroundCustomizationModal');
      if (modal) modal.classList.add('hidden');
    }

    function ensureBackgroundElement() {
      let el = document.getElementById('customBackground');
      if (!el) {
        el = document.createElement('div');
        el.id = 'customBackground';
        document.body.insertBefore(el, document.body.firstChild);
      }
      return el;
    }

    function applyBackgroundToPage(settings) {
      const el = ensureBackgroundElement();
      if (!settings) {
        el.style.backgroundImage = '';
        el.style.backgroundColor = '';
        el.style.filter = '';
        el.style.opacity = '';
        return;
      }

      el.style.filter = `blur(${parseInt(settings.blur || 0, 10)}px)`;
      const zoom = parseInt(settings.zoom || 100, 10);

      if (settings.type === 'image' && settings.imageUrl) {
        el.style.backgroundImage = `url("${settings.imageUrl}")`;
        el.style.backgroundSize = `calc(${zoom}% + 10px)`;
        el.style.backgroundRepeat = 'no-repeat';
        el.style.backgroundPosition = 'center center';
        el.style.backgroundColor = '';
      } else if (settings.type === 'color' && settings.color) {
        el.style.backgroundImage = '';
        el.style.backgroundColor = settings.color;
        el.style.backgroundSize = 'cover';
      } else if (settings.type === 'gradient' && settings.gradientFrom && settings.gradientTo) {
        el.style.backgroundImage = `linear-gradient(${settings.gradientDir || 'to right'}, ${settings.gradientFrom}, ${settings.gradientTo})`;
        el.style.backgroundColor = '';
        el.style.backgroundSize = 'cover';
      } else {
        // clear
        el.style.backgroundImage = '';
        el.style.backgroundColor = '';
      }
    }

    function updatePreviewBox(settings) {
      const preview = document.getElementById('bgPreview');
      if (!preview) return;
      if (!settings) {
        preview.style.backgroundImage = '';
        preview.style.backgroundColor = '';
        preview.style.filter = '';
        return;
      }

      preview.style.filter = `blur(${parseInt(settings.blur || 0, 10)}px)`;
      const zoom = parseInt(settings.zoom || 100, 10);

      if (settings.type === 'image' && settings.imageUrl) {
        preview.style.backgroundImage = `url("${settings.imageUrl}")`;
        preview.style.backgroundSize = `calc(${zoom}% + 10px)`;
        preview.style.backgroundRepeat = 'no-repeat';
        preview.style.backgroundPosition = 'center center';
        preview.style.backgroundColor = '';
      } else if (settings.type === 'color' && settings.color) {
        preview.style.backgroundImage = '';
        preview.style.backgroundColor = settings.color;
      } else if (settings.type === 'gradient' && settings.gradientFrom && settings.gradientTo) {
        preview.style.backgroundImage = `linear-gradient(${settings.gradientDir || 'to right'}, ${settings.gradientFrom}, ${settings.gradientTo})`;
        preview.style.backgroundColor = '';
      } else {
        preview.style.backgroundImage = '';
        preview.style.backgroundColor = '';
      }
    }

    function saveBackgroundSettings() {
      let type = document.querySelector('input[name="bgType"]:checked')?.value || 'image';
      const zoom = document.getElementById('bgZoom')?.value || 100;
      const blur = document.getElementById('bgBlur')?.value || 0;
      const color = document.getElementById('bgColor')?.value;
      const gradientFrom = document.getElementById('bgGradientFrom')?.value;
      const gradientTo = document.getElementById('bgGradientTo')?.value;
      const gradientDir = document.getElementById('bgGradientDir')?.value || 'to right';

      const settings = { type, zoom: parseInt(zoom, 10), blur: parseInt(blur, 10) };

      // Handle uploads: save the data URL as an image so it persists and is applied reliably
      if (type === 'upload') {
        const uploaded = document.getElementById('bgUploadFile')?.dataset?.dataUrl;
        if (uploaded) {
          settings.type = 'image';
          settings.imageUrl = uploaded;
        } else {
          // nothing uploaded; fallback
          settings.type = 'image';
          settings.imageUrl = document.getElementById('bgImageUrl')?.value || '';
        }
      } else if (type === 'image') {
        settings.imageUrl = document.getElementById('bgImageUrl')?.value || document.getElementById('bgUploadFile')?.dataset?.dataUrl || '';
      }

      if (type === 'color') settings.color = color || '';
      if (type === 'gradient') { settings.gradientFrom = gradientFrom || '#ffffff'; settings.gradientTo = gradientTo || '#000000'; settings.gradientDir = gradientDir; }

      localStorage.setItem('backgroundSettings', JSON.stringify(settings));
      applyBackgroundToPage(settings);
      closeBackgroundModal();
    }

    function resetBackgroundSettings() {
      localStorage.removeItem('backgroundSettings');
      const el = document.getElementById('customBackground');
      if (el) { el.style.backgroundImage = ''; el.style.backgroundColor = ''; el.style.filter = ''; }
      updatePreviewBox(null);
      closeBackgroundModal();
    }

    function loadBackgroundSettings() {
      const raw = localStorage.getItem('backgroundSettings');
      const settings = raw ? JSON.parse(raw) : null;
      // Populate modal fields
      if (settings) {
        // Handle uploaded data URLs: map them to upload UI for clarity
        if (settings.type === 'image' && settings.imageUrl && settings.imageUrl.startsWith('data:')) {
          document.querySelector('input[name="bgType"][value="upload"]')?.click();
          const uploadInput = document.getElementById('bgUploadFile');
          if (uploadInput) uploadInput.dataset.dataUrl = settings.imageUrl;
        } else if (settings.type) {
          document.querySelector(`input[name=\"bgType\"][value=\"${settings.type}\"]`)?.click();
        }

        if (settings.zoom) document.getElementById('bgZoom').value = settings.zoom;
        if (settings.blur) document.getElementById('bgBlur').value = settings.blur;
        if (settings.type === 'image' && settings.imageUrl && !settings.imageUrl.startsWith('data:')) document.getElementById('bgImageUrl').value = settings.imageUrl;
        if (settings.type === 'color' && settings.color) document.getElementById('bgColor').value = settings.color;
        if (settings.type === 'gradient') {
          if (settings.gradientFrom) document.getElementById('bgGradientFrom').value = settings.gradientFrom;
          if (settings.gradientTo) document.getElementById('bgGradientTo').value = settings.gradientTo;
          if (settings.gradientDir) setGradientDir(settings.gradientDir);
        }
        updatePreviewBox(settings);
      } else {
        // defaults
        document.getElementById('bgZoom').value = 100;
        document.getElementById('bgBlur').value = 0;
        setGradientDir('to right');
        updatePreviewBox(null);
      }

      // Toggle visible containers based on selected type
      toggleBgTypeContainers();
    }

    function toggleBgTypeContainers() {
      const type = document.querySelector('input[name="bgType"]:checked')?.value || 'image';
      document.getElementById('bgImageUrlContainer').classList.toggle('hidden', type !== 'image');
      document.getElementById('bgUploadContainer').classList.toggle('hidden', type !== 'upload');
      document.getElementById('bgColorContainer').classList.toggle('hidden', type !== 'color');
      document.getElementById('bgGradientContainer').classList.toggle('hidden', type !== 'gradient');
    }

    function handleBgUploadFile(e) {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const maxBytes = 2 * 1024 * 1024; // 2 MB
      if (file.size > maxBytes) { alert('File too large (max 2MB).'); return; }
      const reader = new FileReader();
      reader.onload = function(ev) {
        const dataUrl = ev.target.result;
        const input = document.getElementById('bgUploadFile');
        input.dataset.dataUrl = dataUrl;
        document.getElementById('bgImageUrl').value = '';
        document.querySelector('input[name="bgType"][value="upload"]').checked = true;
        toggleBgTypeContainers();
        const settings = { type: 'image', imageUrl: dataUrl, zoom: document.getElementById('bgZoom').value, blur: document.getElementById('bgBlur').value };
        updatePreviewBox(settings);
        applyBackgroundToPage(settings);
      };
      reader.readAsDataURL(file);
    }

    // Add listeners for modal controls
    document.addEventListener('DOMContentLoaded', function() {
      document.querySelectorAll('input[name="bgType"]').forEach(el => el.addEventListener('change', () => { toggleBgTypeContainers(); const s = getModalSettings(); updatePreviewBox(s); }));
      document.querySelectorAll('.gradient-dir-btn').forEach(btn => btn.addEventListener('click', () => setGradientDir(btn.dataset.dir)));
      document.getElementById('bgUploadFile')?.addEventListener('change', handleBgUploadFile);
      document.getElementById('testBgUrl')?.addEventListener('click', () => {
        const url = document.getElementById('bgImageUrl').value.trim();
        if (!url) return alert('Please enter an image URL to test.');
        const img = new Image();
        img.onload = () => { alert('Image loaded successfully. Click Apply to preview.'); };
        img.onerror = () => { alert('Could not load image. Please check the URL.'); };
        img.src = url;
      });
      document.getElementById('applyBgUrl')?.addEventListener('click', () => {
        const url = document.getElementById('bgImageUrl').value.trim();
        if (!url) return alert('Enter an image URL first.');
        document.querySelector('input[name="bgType"][value="image"]').checked = true;
        toggleBgTypeContainers();
        const settings = { type: 'image', imageUrl: url, zoom: document.getElementById('bgZoom').value, blur: document.getElementById('bgBlur').value };
        updatePreviewBox(settings);
        // Apply as temporary preview to the page (non-persistent until save)
        applyBackgroundToPage(settings);
      });
      document.getElementById('bgZoom')?.addEventListener('input', () => { const s = getModalSettings(); updatePreviewBox(s); });
      document.getElementById('bgBlur')?.addEventListener('input', () => { const s = getModalSettings(); updatePreviewBox(s); });
        document.getElementById('bgPreviewBtn')?.addEventListener('click', () => { openBackgroundPreview(getModalSettings()); });
      document.getElementById('bgSave')?.addEventListener('click', saveBackgroundSettings);
      document.getElementById('bgCancel')?.addEventListener('click', closeBackgroundModal);
      document.getElementById('bgReset')?.addEventListener('click', () => { if (confirm('Reset background to default?')) resetBackgroundSettings(); });

      // Apply saved background on load
      const saved = localStorage.getItem('backgroundSettings');
      if (saved) applyBackgroundToPage(JSON.parse(saved));
    });

    function getModalSettings() {
      const type = document.querySelector('input[name="bgType"]:checked')?.value || 'image';
      const zoom = document.getElementById('bgZoom')?.value || 100;
      const blur = document.getElementById('bgBlur')?.value || 0;
      const color = document.getElementById('bgColor')?.value;
      const gradientFrom = document.getElementById('bgGradientFrom')?.value;
      const gradientTo = document.getElementById('bgGradientTo')?.value;
      const gradientDir = document.getElementById('bgGradientDir')?.value;
      const imageUrl = document.getElementById('bgImageUrl')?.value || document.getElementById('bgUploadFile')?.dataset?.dataUrl;
      const settings = { type, zoom: parseInt(zoom,10), blur: parseInt(blur,10) };
      if (type === 'image') settings.imageUrl = imageUrl;
      if (type === 'color') settings.color = color;
      if (type === 'gradient') { settings.gradientFrom = gradientFrom; settings.gradientTo = gradientTo; settings.gradientDir = gradientDir; }
      return settings;
    }

    function setGradientDir(dir) {
      const hidden = document.getElementById('bgGradientDir');
      if (hidden) hidden.value = dir;
      document.querySelectorAll('.gradient-dir-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.dir === dir);
      });
    }

    // Open a full-page preview using current modal settings. Esc restores the modal.
    function openBackgroundPreview(settings) {
      // hide modal
      const modal = document.getElementById('backgroundCustomizationModal');
      if (modal) modal.classList.add('hidden');

      // apply preview settings temporarily
      applyBackgroundToPage(settings);

      // normalize upload type to image for preview
      if (settings && settings.type === 'upload') {
        const uploaded = document.getElementById('bgUploadFile')?.dataset?.dataUrl;
        settings = { ...settings, type: 'image', imageUrl: uploaded || settings.imageUrl || '' };
      }

      // create overlay and render the background directly on it (ensures preview shows image)
      let overlay = document.getElementById('backgroundPreviewOverlay');
      if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'backgroundPreviewOverlay';
        overlay.innerHTML = '<div class="preview-bg"></div><div class="preview-border"></div><div class="preview-hint">Preview mode ‚Äî press Esc to return to settings</div>';
        document.body.appendChild(overlay);
      }

      // Apply the background onto the overlay so it is visible in preview regardless of page layers
      const bgDiv = overlay.querySelector('.preview-bg');
      if (settings && bgDiv) {
        if (settings.type === 'image' && settings.imageUrl) {
          bgDiv.style.backgroundImage = `url("${settings.imageUrl}")`;
          bgDiv.style.backgroundSize = `calc(${settings.zoom}% + 10px)`;
          bgDiv.style.backgroundRepeat = 'no-repeat';
          bgDiv.style.backgroundPosition = 'center center';
          bgDiv.style.filter = `blur(${parseInt(settings.blur||0,10)}px)`;
        } else if (settings.type === 'color' && settings.color) {
          bgDiv.style.backgroundImage = '';
          bgDiv.style.backgroundColor = settings.color;
          bgDiv.style.filter = '';
        } else if (settings.type === 'gradient' && settings.gradientFrom && settings.gradientTo) {
          bgDiv.style.backgroundImage = `linear-gradient(${settings.gradientDir||'to right'}, ${settings.gradientFrom}, ${settings.gradientTo})`;
          bgDiv.style.backgroundColor = '';
          bgDiv.style.filter = '';
        } else {
          bgDiv.style.backgroundImage = '';
          bgDiv.style.backgroundColor = '';
          bgDiv.style.filter = '';
        }
      } else if (bgDiv) {
        bgDiv.style.backgroundImage = '';
        bgDiv.style.backgroundColor = '';
        bgDiv.style.filter = '';
      }

      // esc handler
      function escHandler(e) {
        if (e.key === 'Escape') {
          closeBackgroundPreview();
        }
      }

      // store handler so we can remove it later
      overlay._escHandler = escHandler;
      document.addEventListener('keydown', escHandler);
    }

    function closeBackgroundPreview() {
      const overlay = document.getElementById('backgroundPreviewOverlay');
      if (overlay) {
        document.removeEventListener('keydown', overlay._escHandler);
        overlay.remove();
      }
      // re-open modal
      const modal = document.getElementById('backgroundCustomizationModal');
      if (modal) modal.classList.remove('hidden');
      // restore modal preview box to current modal settings
      const s = getModalSettings();
      updatePreviewBox(s);
      // reapply saved background (if any) to ensure we don't leave an unsaved preview
      const saved = localStorage.getItem('backgroundSettings');
      if (saved) applyBackgroundToPage(JSON.parse(saved));
      else applyBackgroundToPage(null);
    }

    function clearAllData() {
      if (confirm('Are you sure you want to clear all data? This will remove all shortcuts, notes, widget preferences, and settings. This action cannot be undone.')) {
        // Clear all localStorage
        const keysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && (key.includes('shortcuts') || key.includes('notes') || key.includes('pomodoro') || key.includes('weather') || key.includes('widgetPins'))) {
            keysToRemove.push(key);
          }
        }

        keysToRemove.forEach(key => localStorage.removeItem(key));

        // Refresh the page to show clean state
        showNotification('All data cleared successfully!', 'success');
        setTimeout(() => {
          location.reload();
        }, 1500);
      }
    }

    // ==================== FOLDER SYSTEM ====================

    // Function to generate the "Create Folder" button
    function generateCreateFolderButton() {
      return `
        <button onclick="openCreateFolderModal()"
          class="group p-6 backdrop-blur-xl bg-gradient-to-br from-purple-400/30 to-pink-400/30 rounded-2xl shadow-lg hover:shadow-xl hover:from-purple-400/40 hover:to-pink-400/40 transition-all duration-300 border-2 border-dashed border-white/30 w-full">
          <div class="text-center">
            <div class="flex justify-center mb-2">
              <svg class="w-8 h-8 text-white/70" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"></path>
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 11v6m-3-3h6"></path>
              </svg>
            </div>
            <div class="text-white/70 font-medium">Create Folder</div>
          </div>
        </button>`;
    }

    // Open modal to create a new folder
    function openCreateFolderModal() {
      const modal = document.getElementById('createFolderModal');
      const input = document.getElementById('folderNameInput');
      modal.classList.remove('hidden');
      input.value = '';
      setTimeout(() => input.focus(), 100);
    }

    // Close folder creation modal
    function closeCreateFolderModal() {
      document.getElementById('createFolderModal').classList.add('hidden');
    }

    // Create a new folder
    function createFolder() {
      const input = document.getElementById('folderNameInput');
      const folderName = input.value.trim();
      
      if (!folderName) {
        alert('Please enter a folder name');
        return;
      }

      const activeTab = localStorage.getItem("activeTab") || "personal";
      const folders = JSON.parse(localStorage.getItem(`folders_${activeTab}`) || "{}");
      
      // Generate unique folder ID
      const folderId = 'folder_' + Date.now();
      
      // Create folder data
      folders[folderId] = {
        id: folderId,
        name: folderName,
        position: Object.keys(JSON.parse(localStorage.getItem(`shortcuts_${activeTab}`) || "{}")).length,
        shortcuts: {},
        createdAt: new Date().toISOString()
      };
      
      // Save folder
      localStorage.setItem(`folders_${activeTab}`, JSON.stringify(folders));
      
      closeCreateFolderModal();
      reloadShortcuts();
      
      showNotification(`Folder "${folderName}" created!`);
    }

    // Generate folder HTML (displays as a shortcut with mini icons)
    function generateFolderShortcut(folder) {
      const shortcuts = folder.shortcuts || {};
      const shortcutEntries = Object.values(shortcuts).slice(0, 4); // Max 4 icons (2x2)
      const hasShortcuts = shortcutEntries.length > 0;
      
      // Generate folder icon content
      let folderIconHTML = '';
      
      if (hasShortcuts) {
        // Generate mini icons grid when folder has shortcuts (2x2)
        let miniIconsHTML = '';
        for (let i = 0; i < 4; i++) {
          if (shortcutEntries[i]) {
            const shortcut = shortcutEntries[i];
            const iconSrc = shortcut.imageUrl || shortcut.iconURL || shortcut.faviconUrl || 'data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22><text y=%2218%22 font-size=%2218%22>üìÅ</text></svg>';
            miniIconsHTML += `
              <div class="w-full h-full bg-white/20 rounded-md flex items-center justify-center overflow-hidden">
                <img src="${iconSrc}" alt="" class="w-full h-full object-cover" onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22><text y=%2218%22 font-size=%2218%22>üìÅ</text></svg>'"/>
              </div>`;
          } else {
            miniIconsHTML += `<div class="w-full h-full bg-white/10 rounded-md"></div>`;
          }
        }
        folderIconHTML = `<div class="grid grid-cols-2 grid-rows-2 gap-1 w-20 h-20 mx-auto mb-2" style="display: grid !important;">${miniIconsHTML}</div>`;
      } else {
        // Show simple folder icon when empty
        folderIconHTML = `
          <div class="w-20 h-20 mx-auto mb-2 flex items-center justify-center">
            <svg class="w-16 h-16 text-white/70" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"></path>
            </svg>
          </div>`;
      }
      
      return `
        <div class="shortcut-container">
          <a href="#" onclick="openFolder('${folder.id}'); return false;" 
             oncontextmenu="showFolderContextMenu(event, '${folder.id}'); return false;"
             data-folder-id="${folder.id}"
             class="group block p-4 backdrop-blur-xl bg-gradient-to-br from-purple-500/30 to-pink-500/30 rounded-2xl shadow-lg hover:shadow-xl hover:scale-105 transition-all duration-300 relative">
            
            <!-- Folder icon (grid of shortcuts or simple folder icon) -->
            ${folderIconHTML}
            
            <div class="text-center">
              <div class="text-sm font-medium text-white truncate">${folder.name}</div>
              <div class="text-xs text-white/60 mt-1">${Object.keys(shortcuts).length} items</div>
            </div>
          </a>
        </div>`;
    }

    // Open folder view
    function openFolder(folderId) {
      const activeTab = localStorage.getItem("activeTab") || "personal";
      const folders = JSON.parse(localStorage.getItem(`folders_${activeTab}`) || "{}");
      const folder = folders[folderId];
      
      if (!folder) {
        console.error('Folder not found:', folderId);
        return;
      }
      
      // Save current view state
      localStorage.setItem('currentView', 'folder');
      localStorage.setItem('currentFolderId', folderId);
      
      // Update UI to show folder view
      displayFolderView(folder);
    }

    // Display folder view (like a separate layout)
    function displayFolderView(folder) {
      const grid = document.getElementById('shortcutGrid');
      const shortcuts = folder.shortcuts || {};
      
      // Clear grid
      grid.innerHTML = '';
      
      // Add back button
      const backButton = document.createElement('div');
      backButton.className = 'col-span-full mb-4';
      backButton.innerHTML = `
        <button onclick="exitFolderView()" 
                class="flex items-center gap-2 px-4 py-2 backdrop-blur-xl bg-white/30 rounded-xl hover:bg-white/40 transition-all">
          <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
          </svg>
          <span class="text-white font-medium">${folder.name}</span>
        </button>`;
      grid.appendChild(backButton);
      
      // Get shortcut count for this folder
      const shortcutCount = parseInt(localStorage.getItem(`folderShortcutCount_${folder.id}`) || "8");
      
      // Generate shortcuts for folder
      for (let i = 0; i < shortcutCount; i++) {
        const shortcutHTML = generateShortcut(i);
        grid.insertAdjacentHTML('beforeend', shortcutHTML);
      }
      
      // Update shortcuts with saved data
      Object.entries(shortcuts).forEach(([position, data]) => {
        const shortcut = document.querySelector(`a[data-position="${position}"]`);
        if (shortcut) {
          const iconContainer = shortcut.querySelector('.shortcut-icon');
          const imgSrc = data.imageUrl || data.iconURL || data.faviconUrl || '';
          iconContainer.innerHTML = `<img src="${imgSrc}" alt="${data.title}" class="w-8 h-8 min-w-[2rem] min-h-[2rem] max-w-[2rem] max-h-[2rem] mt-2 mb-2 group-hover:scale-120 transition-transform duration-300 object-cover rounded" style="aspect-ratio: 1/1;"/>`;
          iconContainer.setAttribute('data-empty', 'false');
          shortcut.querySelector('.shortcut-title').textContent = data.title;
          shortcut.href = data.url;
        }
      });
      
      // Add "Add more shortcuts" button for folder
      grid.insertAdjacentHTML('beforeend', generateAddRowButton());
      
      // Update the add row button to work within folder context
      const addButton = document.getElementById('addRowButton');
      if (addButton) {
        addButton.onclick = () => addMoreShortcutsToFolder(folder.id);
      }
    }

    // Exit folder view and return to main view
    function exitFolderView() {
      localStorage.removeItem('currentView');
      localStorage.removeItem('currentFolderId');
      reloadShortcuts();
    }

    // Add more shortcuts to a folder
    function addMoreShortcutsToFolder(folderId) {
      const currentCount = document.querySelectorAll("[data-position]").length;
      localStorage.setItem(`folderShortcutCount_${folderId}`, currentCount + 4);
      
      const activeTab = localStorage.getItem("activeTab") || "personal";
      const folders = JSON.parse(localStorage.getItem(`folders_${activeTab}`) || "{}");
      const folder = folders[folderId];
      
      displayFolderView(folder);
    }

    // Show context menu for folder
    function showFolderContextMenu(event, folderId) {
      event.preventDefault();
      const contextMenu = document.getElementById("folderContextMenu");
      contextMenu.style.left = `${event.pageX}px`;
      contextMenu.style.top = `${event.pageY}px`;
      contextMenu.setAttribute("data-folder-id", folderId);
      contextMenu.classList.remove("hidden");
      
      document.addEventListener("click", closeFolderContextMenu);
    }

    // Close folder context menu
    function closeFolderContextMenu() {
      document.getElementById("folderContextMenu").classList.add("hidden");
      document.removeEventListener("click", closeFolderContextMenu);
    }

    // Rename folder
    function renameFolder(folderId) {
      const activeTab = localStorage.getItem("activeTab") || "personal";
      const folders = JSON.parse(localStorage.getItem(`folders_${activeTab}`) || "{}");
      const folder = folders[folderId];
      
      if (!folder) return;
      
      const newName = prompt('Enter new folder name:', folder.name);
      if (newName && newName.trim()) {
        folder.name = newName.trim();
        localStorage.setItem(`folders_${activeTab}`, JSON.stringify(folders));
        closeFolderContextMenu();
        reloadShortcuts();
        showNotification(`Folder renamed to "${newName}"`);
      }
    }

    // Delete folder
    function deleteFolder(folderId) {
      if (!confirm('Delete this folder and all its contents?')) return;
      
      const activeTab = localStorage.getItem("activeTab") || "personal";
      const folders = JSON.parse(localStorage.getItem(`folders_${activeTab}`) || "{}");
      
      delete folders[folderId];
      localStorage.setItem(`folders_${activeTab}`, JSON.stringify(folders));
      localStorage.removeItem(`folderShortcutCount_${folderId}`);
      
      closeFolderContextMenu();
      
      // If we're currently in this folder, exit
      if (localStorage.getItem('currentFolderId') === folderId) {
        exitFolderView();
      } else {
        reloadShortcuts();
      }
      
      showNotification('Folder deleted');
    }

    document.addEventListener('click', (e) => {
      const settingsMenu = document.getElementById('settingsMenu');
      const settingsButton = e.target.closest('[onclick*="toggleSettingsMenu"]');

      if (settingsMenu && !settingsMenu.contains(e.target) && !settingsButton) {
        settingsMenu.classList.add('hidden');
      }
    });

  </script>

</head>

<body class="min-h-screen font-sf">

  <!-- Button to show sidebar when collapsed -->
  <button id="showSidebarBtn" onclick="toggleSidebar()" title="Show sidebar">
    <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
    </svg>
  </button>

  <div class="flex min-h-screen p-6">
    <aside id="sidebar"
      class="w-80 backdrop-blur-xl bg-white/90 rounded-3xl p-6 space-y-4 shadow-2xl transition-all duration-300 mr-6 fixed lg:relative z-40 h-[calc(100vh-3rem)] overflow-y-auto hidden lg:block scrollbar-hide">

      <div
        class="pr-4 pt-4 pb-4 pl-2 hover:bg-white/60 rounded-xl cursor-pointer text-white transition-all duration-300 flex items-center gap-3 bg-white/30"
        onclick="switchTab('personal')" id="personalTab">
        <svg class="pl-2 w-9 text-white" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
          <path
            d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z" />
        </svg>
        <a id="perso" class="block w-full">Personal</a>
      </div>
      <div
        class="pr-4 pt-4 pb-4 pl-2 hover:bg-white/60 rounded-xl cursor-pointer text-white transition-all duration-300 flex items-center gap-3 bg-white/30"
        onclick="switchTab('professional')" id="professionalTab">
        <svg class="pl-2 w-9 text-white" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
          <path
            d="M20 6h-4V4c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-6 0h-4V4h4v2z" />
        </svg>
        <a id="pro" class="block w-full">Professional</a>
      </div>

      <!-- Widgets Slider -->
      <div class="mt-6">
        <!-- Slider Header with Navigation -->
        <div class="flex items-center justify-between mb-4 pr-4 pt-4 pb-2 pl-2">
          <div class="flex items-center gap-2">
            <div id="current-widget-icon" class="w-6 h-6 text-white">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round"
                  d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
              </svg>
            </div>
            <h3 id="current-widget-title" class="text-white font-medium text-lg">Weather</h3>
          </div>

          <!-- Navigation Controls -->
          <div class="flex items-center gap-2">
            <!-- Pin Menu Button -->
            <div class="relative">
              <button onclick="toggleWidgetPinMenu()" id="widgetPinButton"
                class="w-8 h-8 bg-white/20 hover:bg-white/30 rounded-full flex items-center justify-center transition-colors">
                <img src="../media/pin.svg" alt="Pin" class="w-4 h-4" />
              </button>
              <div id="widgetPinMenu"
                class="hidden absolute top-full right-0 mt-2 bg-black/60 backdrop-blur-xl rounded-lg shadow-lg min-w-[140px] z-50 border border-white/10">
                <button onclick="pinWidget('primary')"
                  class="w-full px-3 py-2 text-left text-white hover:bg-white/10 rounded-t-lg text-sm">
                  üìå Pin as Primary
                </button>
                <button onclick="pinWidget('secondary')"
                  class="w-full px-3 py-2 text-left text-white hover:bg-white/10 text-sm">
                  üìé Pin as Secondary
                </button>
                <button onclick="unpinWidget()"
                  class="w-full px-3 py-2 text-left text-white hover:bg-white/10 rounded-b-lg text-sm">
                  ‚ùå Unpin Widget
                </button>
              </div>
            </div>
            <button onclick="previousWidget()"
              class="w-8 h-8 bg-white/20 hover:bg-white/30 rounded-full flex items-center justify-center transition-colors">
              <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
              </svg>
            </button>
            <button onclick="nextWidget()"
              class="w-8 h-8 bg-white/20 hover:bg-white/30 rounded-full flex items-center justify-center transition-colors">
              <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
              </svg>
            </button>
          </div>
        </div>

        <!-- Slider Container -->
        <div class="relative overflow-hidden rounded-xl">
          <div id="widgets-slider" class="flex transition-transform duration-500 ease-in-out"
            style="transform: translateX(0%);">

            <!-- Weather Widget Slide -->
            <div class="w-full flex-shrink-0">
              <div id="weather-widget"
                class="pr-4 pt-4 pb-4 pl-2 rounded-xl text-white transition-all duration-300 border-2 border-white-500/60 height-[300px] flex flex-col justify-between"
                style="background: linear-gradient(135deg, #6578FF 0%, #B1B8EF 100%);">

                <!-- City Input -->
                <div id="weather-input" class="mb-4">
                  <div class="flex gap-2 hop-colonne">
                    <input type="text" id="weather-city-input" placeholder="Enter city name..."
                      class="flex-1 px-3 py-2 bg-white/20 rounded-lg text-white placeholder-white/60 border border-white/20 focus:border-white/40 focus:outline-none text-sm"
                      onkeypress="if(event.key==='Enter') loadWeatherForCity()">
                    <button onclick="loadWeatherForCity()"
                      class="px-3 py-2 bg-blue-500/60 hover:bg-blue-500/80 rounded-lg text-white text-sm transition-colors">
                      Get Weather
                    </button>
                    <button onclick="saveCurrentCity()"
                      class="px-3 py-2 bg-green-500/60 hover:bg-green-500/80 rounded-lg text-white text-sm transition-colors"
                      title="Save current city">
                      üíæ
                    </button>
                  </div>
                  <div class="text-xs text-white/60 mt-1">Press Enter or click "Get Weather"</div>

                  <!-- Saved Cities -->
                  <div id="saved-cities" class="mt-3" style="display: none;">
                    <div class="flex items-center justify-between mb-2">
                      <div class="text-xs text-white/70">Saved Cities:</div>
                      <div class="text-xs text-white/50" id="cities-count"></div>
                    </div>
                    <div id="saved-cities-list" class="flex flex-wrap gap-1">
                      <!-- Saved cities will be populated here -->
                    </div>
                  </div>
                </div>

                <div id="weather-loading" class="hidden flex items-center justify-center py-8">
                  <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div>
                  <span class="ml-2">Loading weather...</span>
                </div>

                <div id="weather-content" class="hidden">
                  <!-- Weather Header -->
                  <div class="text-center mb-6">
                    <h2 class="text-2xl font-bold text-white mb-2">WEATHER IN</h2>
                    <h1 id="weather-city-name" class="text-4xl font-bold text-white tracking-wider"
                      style="font-weight: 800; letter-spacing: 0.15em;">PARIS</h1>
                  </div>

                  <!-- Current Weather Icon and Temperature -->
                  <div class="text-center mb-6">
                    <div id="weather-icon" class="flex justify-center items-center mb-4 min-h-[4rem]" style="font-size: 50px;">‚òÄÔ∏è</div>
                    <div id="weather-temp" class="text-5xl font-bold text-white mb-2">26¬∞C</div>
                    <div id="weather-location" class="text-lg text-white/90 mb-1">Paris, France</div>
                    <div id="weather-description" class="text-md text-white/80 capitalize">Clear sky</div>
                  </div>

                  <!-- Weather Forecast -->
                  <div id="weather-forecast" class="space-y-3">
                    <!-- Forecast items will be populated here -->
                  </div>

                  <button onclick="showCityInput()"
                    class="w-full mt-4 px-3 py-2 bg-white/20 hover:bg-white/30 rounded-lg text-white/80 text-xs transition-colors text-center">
                    Change city
                  </button>
                </div>

                <div id="weather-error" class="hidden text-center py-4">
                  <div class="text-red-300 mb-2">‚ö†Ô∏è Unable to load weather</div>
                  <div class="text-xs text-white/60 mb-3">Please check the city name and try again</div>
                  <button onclick="showCityInput()" class="text-sm text-blue-300 hover:text-blue-200 underline">
                    Try again
                  </button>
                </div>
              </div>
            </div>

            <!-- Notes Widget Slide -->
            <div class="w-full flex-shrink-0">
              <div id="notes-widget"
                class="pr-4 pt-4 pb-4 pl-2 rounded-xl text-white transition-all duration-300 border-2 border-white-500/60"
                style="background: linear-gradient(135deg, #6578FF 0%, #B1B8EF 100%);">

                <!-- Add Note Button -->
                <div class="mb-4">
                  <button onclick="showAddNoteForm()"
                    class="w-full px-3 py-2 bg-white/20 hover:bg-white/30 rounded-lg text-white text-sm transition-colors flex items-center justify-center gap-2">
                    <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                    </svg>
                    New note
                  </button>
                </div>

                <!-- Add Note Form -->
                <div id="add-note-form" class="hidden mb-4">
                  <div class="space-y-3">
                    <textarea id="note-text" placeholder="Write your note..."
                      class="w-full px-3 py-2 bg-white/20 rounded-lg text-white placeholder-white/60 border border-white/20 focus:border-white/40 focus:outline-none text-base resize-none font-patrick"
                      rows="3"></textarea>
                    <div class="flex gap-2">
                      <button onclick="addNote('yellow')"
                        class="flex-1 h-8 bg-yellow-300 rounded border-2 border-white/20 hover:border-white/40 transition-colors"></button>
                      <button onclick="addNote('green')"
                        class="flex-1 h-8 bg-green-300 rounded border-2 border-white/20 hover:border-white/40 transition-colors"></button>
                      <button onclick="addNote('pink')"
                        class="flex-1 h-8 bg-pink-300 rounded border-2 border-white/20 hover:border-white/40 transition-colors"></button>
                      <button onclick="addNote('blue')"
                        class="flex-1 h-8 bg-blue-300 rounded border-2 border-white/20 hover:border-white/40 transition-colors"></button>
                    </div>
                    <div class="flex gap-2">
                      <button onclick="hideAddNoteForm()"
                        class="flex-1 px-3 py-2 bg-white/20 hover:bg-white/30 rounded-lg text-white text-xs transition-colors">
                        Cancel
                      </button>
                      <button onclick="addNote('yellow')"
                        class="flex-1 px-3 py-2 bg-blue-500/60 hover:bg-blue-500/80 rounded-lg text-white text-xs transition-colors">
                        Add Note
                      </button>
                    </div>
                  </div>
                </div>

                <!-- Notes Container -->
                <div id="notes-container" class="space-y-3">
                  <!-- Notes will be populated here -->
                </div>

                <!-- Empty State -->
                <div id="notes-empty" class="text-center py-8 text-white/60">
                  <div class="text-4xl mb-2">üìù</div>
                  <div class="text-sm">No notes yet</div>
                  <div class="text-xs mt-1">Click "New note" to get started</div>
                </div>
              </div>
            </div>

            <!-- Pomodoro Widget Slide -->
            <div class="w-full flex-shrink-0">
              <div id="pomodoro-widget"
                class="pr-4 pt-3 pb-3 mb-6 pl-4 rounded-xl text-white transition-all duration-300 border-2 border-white-500/60 relative overflow-hidden"
                style="background: linear-gradient(135deg, #6578FF 0%, #B1B8EF 100%);">

                <!-- Close button (like in the design) -->
                <div class="absolute top-4 right-4">
                  <button onclick="resetPomodoro()"
                    class="w-8 h-8 bg-white/20 hover:bg-white/30 rounded-full flex items-center justify-center transition-colors">
                    <svg class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 24 24">
                      <path
                        d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" />
                    </svg>
                  </button>
                </div>

                <!-- Header with task name -->
                <div class="text-center mb-6">
                  <br>
                  <br>
                  <div id="pomodoro-message" class="text-xl font-semibold text-white mb-6">Focus on your work !</div>
                </div>

                <!-- Large Timer Display -->
                <div class="text-center mb-8">
                  <div id="pomodoro-timer" class="font-bold text-white tracking-tight font-mono mb-2"
                    style="font-size: 5rem; line-height: 0.9;">25:00</div>
                </div>

                <!-- Progress Ring with Emoji -->
                <div class="flex justify-center mb-8">
                  <div class="relative w-32 h-32">
                    <svg class="w-32 h-32 transform -rotate-90" viewBox="0 0 100 100">
                      <!-- Background circle -->
                      <circle cx="50" cy="50" r="42" stroke="rgba(255,255,255,0.15)" stroke-width="12" fill="none" />
                      <!-- Progress circle -->
                      <circle id="pomodoro-progress" cx="50" cy="50" r="42" stroke="#22D3EE" stroke-width="12"
                        fill="none" stroke-linecap="round" stroke-dasharray="264" stroke-dashoffset="264"
                        class="transition-all duration-1000 ease-linear" />
                    </svg>
                    <div class="absolute inset-0 flex items-center justify-center">
                      <span id="pomodoro-emoji" class="text-4xl">üß†</span>
                    </div>
                  </div>
                </div>

                <!-- Simple Controls -->
                <div class="flex gap-3 mb-6">
                  <button id="pomodoro-start" onclick="startPomodoro()"
                    class="flex-1 px-6 py-4 bg-white/20 hover:bg-white/30 rounded-2xl text-white font-medium transition-colors text-lg">
                    Start Focus
                  </button>
                  <button id="pomodoro-pause" onclick="pausePomodoro()"
                    class="flex-1 px-6 py-4 bg-white/20 hover:bg-white/30 rounded-2xl text-white font-medium transition-colors text-lg hidden">
                    Pause
                  </button>
                </div>

                <!-- Mode and Session Info -->
                <div class="text-center">
                  <div id="pomodoro-mode" class="text-sm text-white/70 mb-1">FOCUS SESSION</div>
                  <div id="pomodoro-session" class="text-sm text-white/70">Session 1 of 4</div>
                </div>

                <!-- Settings Toggle -->
                <div class="mt-4 mb-0 text-center">
                  <button onclick="togglePomodoroSettings()"
                    class="text-sm text-white/60 hover:text-white/80 transition-colors">
                    ‚öôÔ∏è Settings
                  </button>
                </div>

                <!-- Collapsible Settings -->
                <div id="pomodoro-settings" class="hidden mt-4 pt-4 border-t border-white/20 space-y-3">
                  <div class="flex items-center justify-between">
                    <span class="text-sm text-white/80">Focus time</span>
                    <div class="flex items-center gap-2">
                      <button onclick="adjustTime('focus', -5)"
                        class="w-8 h-8 bg-white/15 hover:bg-white/25 rounded-full text-white text-sm">‚àí</button>
                      <span id="focus-time" class="text-xs font-medium min-w-[3rem] text-center">25 min</span>
                      <button onclick="adjustTime('focus', 5)"
                        class="w-8 h-8 bg-white/15 hover:bg-white/25 rounded-full text-white text-sm">+</button>
                    </div>
                  </div>
                  <div class="flex items-center justify-between">
                    <span class="text-sm text-white/80">Break time</span>
                    <div class="flex items-center gap-2">
                      <button onclick="adjustTime('break', -1)"
                        class="w-8 h-8 bg-white/15 hover:bg-white/25 rounded-full text-white text-sm">‚àí</button>
                      <span id="break-time" class="text-xs font-medium min-w-[3rem] text-center">5 min</span>
                      <button onclick="adjustTime('break', 1)"
                        class="w-8 h-8 bg-white/15 hover:bg-white/25 rounded-full text-white text-sm">+</button>
                    </div>
                  </div>

                  <!-- Stats in settings -->
                  <div class="pt-3 border-t border-white/10">
                    <div class="flex justify-between text-xs text-white/60">
                      <span>Today: <span id="today-sessions">0</span></span>
                      <span>Total: <span id="total-sessions">0</span></span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Widget Indicators -->
        <div class="flex justify-center gap-2 mt-0">
          <button onclick="goToWidget(0)" class="w-2 h-2 rounded-full transition-colors duration-300 bg-white/60"
            id="indicator-0"></button>
          <button onclick="goToWidget(1)" class="w-2 h-2 rounded-full transition-colors duration-300 bg-white/30"
            id="indicator-1"></button>
          <button onclick="goToWidget(2)" class="w-2 h-2 rounded-full transition-colors duration-300 bg-white/30"
            id="indicator-2"></button>
        </div>
      </div>
    </aside>

    
    <main class="flex-1 flex flex-col lg:ml-80 pb-20 lg:pb-0">
      
      <div class="max-w-2xl mx-auto w-full mb-12 flex items-center gap-4 search-container relative z-30">
        <div class="relative"> <button id="currentSearch"
            class="relative z-[999999] px-5 h-12 bg-white/20  rounded-xl border-0 outline-none cursor-pointer transition-all duration-300 flex items-center justify-center">
            <span class="pr-3 shortcut-title font-sf" style="font-weight: 400">Search on:</span>
            <img src="https://www.google.com/images/branding/product/ico/googleg_lodp.ico" class="w-6 h-6"
              alt="Google" />
          </button>
          
          <div id="searchEngineDropdown" class="hidden absolute top-full left-0 mt-2 rounded-xl p-3 grid grid-cols-4 gap-3">
            <button class="search-option rounded-lg" data-value="g">
              <img src="https://favicone.com/www.google.com?s=128" alt="Google" />
            </button>
            <button class="search-option rounded-lg" data-value="yt">
              <img src="https://dev.kilianbarbier.fr/media/img/youtube_logo.svg" alt="YouTube" />
            </button>
            <button class="search-option p-2 rounded-lg" data-value="gh">
              <img src="https://favicone.com/github.com?s=128" class="w-6 h-6" alt="GitHub" />
            </button>
            <button class="search-option p-2 rounded-lg" data-value="w">
              <img src="https://favicone.com/wikipedia.org?s=128" class="w-6 h-6" alt="Wikipedia" />
            </button>
            <button class="search-option p-2 rounded-lg" data-value="r">
              <img src="https://favicone.com/www.reddit.com?s=128" class="w-6 h-6" alt="Reddit" />
            </button>
            <button class="search-option p-2 rounded-lg" data-value="so">
              <img src="https://favicone.com/stackoverflow.com?s=128" class="w-6 h-6" alt="Stack" />
            </button>
            <button class="search-option p-2 rounded-lg" data-value="a">
              <img src="https://favicone.com/www.amazon.com?s=128" class="w-6 h-6" alt="Amazon" />
            </button>
            <button class="search-option p-2 rounded-lg" data-value="n">
              <img src="https://favicone.com/www.netflix.com?s=128" class="w-6 h-6" alt="Netflix" />
            </button>
            <button class="search-option p-2 rounded-lg" data-value="sp">
              <img src="https://favicone.com/open.spotify.com?s=128" class="w-6 h-6" alt="Spotify" />
            </button>
            <button class="search-option p-2 rounded-lg" data-value="tw">
              <img src="https://favicone.com/twitter.com?s=128" class="w-6 h-6" alt="Twitter" />
            </button>
            <button class="search-option p-2 rounded-lg" data-value="ig">
              <img src="https://favicone.com/www.instagram.com?s=128" class="w-6 h-6" alt="Instagram" />
            </button>
            <button class="search-option p-2 rounded-lg" data-value="maps">
              <img src="https://favicone.com/maps.google.com?s=128" class="w-6 h-6" alt="Maps" />
            </button>
            <button class="search-option p-2 rounded-lg" data-value="i">
              <img src="https://dev.kilianbarbier.fr/media/img/google_img_logo.svg" class="w-6 h-6" alt="Images" />
            </button>
            <button class="search-option p-2 rounded-lg" data-value="ddg">
              <img src="https://favicone.com/duckduckgo.com?s=128" class="w-6 h-6" alt="DuckDuckGo" />
            </button>
            <button class="search-option p-2 rounded-lg" data-value="px">
              <img src="https://favicone.com/www.perplexity.ai?s=128" class="w-6 h-6" alt="Perplexity" />
            </button>
          </div>
          <select id="searchEngine" class="hidden">
            <option value="g">Google</option>
            <option value="yt">YouTube</option>
            <option value="gh">GitHub</option>
            <!-- ... keep the values for search functionality ... -->
          </select>
        </div>

        <div class="relative flex-1">
          <input type="text" placeholder="Search..." id="searchInput"
            class="w-full px-6 py-4 rounded-2xl shadow-lg border-0 bg-white/90 text-white text-lg focus:outline-none focus:ring-2 focus:ring-blue-400/30 transition-all duration-300 placeholder-white/50" />
          <svg class="absolute right-4 top-1/2 transform -translate-y-1/2 w-6 h-6 text-white" viewBox="0 0 24 24"
            fill="none" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="{2}"
              d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
        </div>
        <div id="searchCounter"
          class="relative z-[999999] px-5 h-12 bg-white/20 rounded-xl border-0 outline-none cursor-pointer transition-all duration-300 flex items-center justify-center">
          0s</div>
        <button onclick="showSearchHelp()" class="text-white text-xl font-medium w-10 h-10 rounded-full bg-white/20 flex items-center justify-center
           transition-all duration-300">
          ?
        </button>
      </div>

      <!-- Grid Shortcuts -->
      <div id="shortcutGrid" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6 max-w-5xl mx-auto w-full">
      </div>

      <!-- Configuration Modal simplifi√© -->
      <div id="configModal" class="hidden fixed inset-0 bg-black/40 backdrop-blur-xl flex items-center justify-center">
        <div class="modal-content bg-white/95 rounded-2xl p-6 w-96 shadow-2xl backdrop-blur-xl">
          <h2 class="text-2xl font-bold mb-4 text-gray-900">Add a shortcut</h2>
          <div class="space-y-4">
            <div>
              <label class="block text-sm font-medium text-gray-700">Title</label>
              <input type="text" id="shortcutTitle" oninput="validateForm()" placeholder="Facebook"
                class="mt-1 w-full rounded-lg px-3 py-2 text-gray-900 bg-gray-50 placeholder-gray-400" />
            </div>
            <div>
              <label class="block text-sm font-medium text-gray-700">URL</label>
              <input type="url" id="shortcutUrl" oninput="validateForm()" placeholder="facebook.com"
                class="mt-1 w-full rounded-lg px-3 py-2 text-gray-900 bg-gray-50 placeholder-gray-400" />
              <p id="urlError" class="mt-1 text-sm text-red-500 hidden">
                Please enter a valid URL (e.g. google.com)
              </p>
            </div>

            <!-- Image / Icon selection -->
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-2">Icon or image</label>
              <div class="flex items-center gap-4">
                <label class="text-sm"><input type="radio" name="imageSource" value="favicon" checked onchange="toggleImageInputs()"> Use site icon</label>
                <label class="text-sm"><input type="radio" name="imageSource" value="url" onchange="toggleImageInputs()"> Image URL</label>
                <label class="text-sm"><input type="radio" name="imageSource" value="upload" onchange="toggleImageInputs()"> Upload file</label>
              </div>

              <div id="imageUrlContainer" class="mt-2 hidden">
                <input type="url" id="shortcutImageUrl" oninput="validateForm(); updateImagePreview()" placeholder="https://example.com/my-icon.png"
                  class="mt-1 w-full rounded-lg px-3 py-2 text-gray-900 bg-gray-50 placeholder-gray-400" />
              </div>

              <div id="imageUploadContainer" class="mt-2 hidden">
                <input type="file" id="shortcutImageFile" accept="image/*" onchange="handleImageFileSelect(event)" />
              </div>

              <div id="shortcutImagePreview" class="mt-3">
                <img id="shortcutImagePreviewImg" src="" alt="Preview" class="hidden w-16 h-16 object-cover rounded-md border" />
              </div>
            </div>

            <div class="flex justify-end gap-2 mt-6">
              <button onclick="closeConfigModal()" class="px-4 py-2 rounded-lg bg-gray-200 text-gray-700">
                Cancel
              </button>
              <button id="saveButton" onclick="saveShortcut()" disabled
                class="px-4 py-2 rounded-lg bg-blue-400/80 text-white transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed hover:bg-blue-500/80">
                <span class="flex items-center gap-2 font-medium">
                  <svg class="animate-spin h-4 w-4 text-white hidden" id="saveSpinner"
                    xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity.25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor"
                      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                    </path>
                  </svg> <span id="saveText">Add</span>
                </span></span>
              </button>
            </div>
          </div>
        </div>
      </div>

      <div id="contextMenu"
        class="hidden fixed rounded-lg shadow-2xl min-w-[150px] z-50 bg-black/40 backdrop-blur-xl border border-white/10">
        <button onclick="editShortcut(document.getElementById('contextMenu').getAttribute('data-position'))"
          class="w-full border-t-0 border-r-0 border-l-0 border-b-0 px-4 py-4 text-left hover:bg-white/10 text-gray-200 transition-colors duration-200 transform hover:translate-y-0"
          style="border-top-left-radius: 8px; border-top-right-radius: 8px;">
          Edit Shortcut
        </button>
        <button onclick="pinToBothTabs(document.getElementById('contextMenu').getAttribute('data-position'))"
          class="w-full border-t-0 border-r-0 border-l-0 border-b-0 px-4 py-4 text-left hover:bg-blue-500/20 text-blue-300 transition-colors duration-200 transform hover:translate-y-0">
          Pin to both tabs
        </button>
        <button onclick="deleteShortcut()"
          class="w-full border-b-0 border-r-0 border-l-0 px-4 py-4 text-left hover:bg-red-500/20 text-red-300 transition-colors duration-200 transform hover:translate-y-0"
          style="border-bottom-left-radius: 8px; border-bottom-right-radius: 8px;">
          Delete Shortcut
        </button>
      </div>

      <div id="importModal"
        class="hidden fixed inset-0 bg-black/40 backdrop-blur-xl flex items-center justify-center z-50">
        <div class="bg-white/95 rounded-2xl p-6 w-[500px] shadow-2xl backdrop-blur-xl">
          <h2 class="text-2xl font-bold mb-4 text-gray-900">Import Shortcuts</h2>
          <div class="text-gray-700 mb-6">
            <p class="mb-3">Select a .json file containing your shortcuts to import them.</p>
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 text-sm">
              <strong>‚ö†Ô∏è Important:</strong> This will replace your current shortcuts. Make sure to export your current
              shortcuts first if you want to keep them.
            </div>
          </div>
          <div class="flex justify-end gap-3">
            <button onclick="closeImportModal()"
              class="px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-lg text-gray-700">
              Cancel
            </button>
            <button onclick="triggerFileImport()"
              class="px-4 py-2 bg-blue-500/80 hover:bg-blue-600/80 rounded-lg text-white">
              Choose File
            </button>
          </div>
        </div>
      </div>

      <!-- Popup d'autocorrection -->
      <div id="autocorrectionModal"
        class="hidden fixed inset-0 bg-black/40 backdrop-blur-xl flex items-center justify-center z-50">
        <div class="bg-white/95 rounded-2xl p-6 w-[500px] shadow-2xl backdrop-blur-xl">
          <h2 class="text-2xl font-bold mb-4 text-white">Correction Suggestion</h2>
          <div class="text-white mb-6">
            <p>You entered: <span id="originalQuery" class="font-semibold"></span></p>
            <p class="mt-3">Did you mean: <span id="correctedQuery" class="font-semibold"></span> ?</p>
            <p class="mt-2 text-white/70 text-sm">The search will be performed on Amazon</p>
          </div>
          <div class="flex justify-end gap-3">
            <button onclick="executeOriginalSearch()"
              class="px-4 py-2 bg-white/20 hover:bg-white/30 rounded-lg text-white">
              No
            </button>
            <button onclick="executeCorrectedSearch()"
              class="px-4 py-2 bg-blue-500/80 hover:bg-blue-600/80 rounded-lg text-white">
              Yes
            </button>
          </div>
        </div>
      </div>

      <!-- Background customization modal -->
      <div id="backgroundCustomizationModal" class="hidden fixed inset-0 bg-black/40 backdrop-blur-xl flex items-center justify-center z-50">
        <div class="bg-white/95 rounded-2xl p-6 w-[560px] shadow-2xl backdrop-blur-xl">
          <h2 class="text-2xl font-bold mb-4 text-gray-900">Customize Background</h2>
          <div class="text-gray-700 mb-4 space-y-3">
            <div class="flex gap-3 items-center">
              <label class="flex items-center gap-2 cursor-pointer">
                <input type="radio" name="bgType" value="image" class="bg-type" checked>
                Image URL
              </label>
              <label class="flex items-center gap-2 cursor-pointer">
                <input type="radio" name="bgType" value="upload" class="bg-type">
                Upload
              </label>
              <label class="flex items-center gap-2 cursor-pointer">
                <input type="radio" name="bgType" value="color" class="bg-type">
                Color
              </label>
              <label class="flex items-center gap-2 cursor-pointer">
                <input type="radio" name="bgType" value="gradient" class="bg-type">
                Gradient
              </label>
            </div>

            <div id="bgImageUrlContainer" class="space-y-2">
              <input id="bgImageUrl" type="text" placeholder="https://example.com/image.jpg" class="w-full rounded border px-3 py-2 text-gray-800">
              <div class="flex gap-2">
                <button id="testBgUrl" class="px-3 py-2 bg-blue-500 text-white rounded">Test</button>
                <button id="applyBgUrl" class="px-3 py-2 bg-green-500 text-white rounded">Apply</button>
              </div>
            </div>

            <div id="bgUploadContainer" class="hidden">
              <input id="bgUploadFile" type="file" accept="image/*" class="w-full">
            </div>

            <div id="bgColorContainer" class="hidden">
              <input id="bgColor" type="color" class="w-12 h-12 p-0 border rounded">
            </div>

            <div id="bgGradientContainer" class="hidden space-y-2">
              <div class="flex gap-2 items-center">
                <input id="bgGradientFrom" type="color" class="w-12 h-12 p-0 border rounded">
                <input id="bgGradientTo" type="color" class="w-12 h-12 p-0 border rounded">
                <input type="hidden" id="bgGradientDir" value="to right">
                <div class="flex gap-2 flex-wrap" id="bgGradientDirGroup">
                  <button type="button" class="gradient-dir-btn" data-dir="to left" aria-label="Right to Left">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5"></path><path d="M11 6l-6 6 6 6"></path></svg>
                  </button>
                  <button type="button" class="gradient-dir-btn" data-dir="to right" aria-label="Left to Right">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"></path><path d="M13 6l6 6-6 6"></path></svg>
                  </button>
                  <button type="button" class="gradient-dir-btn" data-dir="to top" aria-label="Bottom to Top">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5"></path><path d="M18 11l-6-6-6 6"></path></svg>
                  </button>
                  <button type="button" class="gradient-dir-btn" data-dir="to bottom" aria-label="Top to Bottom">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14"></path><path d="M6 13l6 6 6-6"></path></svg>
                  </button>
                  <button type="button" class="gradient-dir-btn" data-dir="to top left" aria-label="Bottom-right to Top-left">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 18L6 6"></path><path d="M6 12V6h6"></path></svg>
                  </button>
                  <button type="button" class="gradient-dir-btn" data-dir="to top right" aria-label="Bottom-left to Top-right">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 18l12-12"></path><path d="M12 6h6v6"></path></svg>
                  </button>
                  <button type="button" class="gradient-dir-btn" data-dir="to bottom left" aria-label="Top-right to Bottom-left">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6L6 18"></path><path d="M6 12v6h6"></path></svg>
                  </button>
                  <button type="button" class="gradient-dir-btn" data-dir="to bottom right" aria-label="Top-left to Bottom-right">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 6l12 12"></path><path d="M9 18h9v-9"></path></svg>
                  </button>
                </div>
              </div>
            </div>

            <div class="space-y-2">
              <label class="text-sm">Zoom</label>
              <input id="bgZoom" type="range" min="50" max="200" value="100" class="w-full">
              <label class="text-sm">Blur</label>
              <input id="bgBlur" type="range" min="0" max="20" value="0" class="w-full">
            </div>

            <div class="flex gap-3 items-center">
              <div id="bgPreview" class="w-32 h-20 rounded bg-gray-100 border overflow-hidden"></div>
              <div class="flex flex-col gap-2">
                <button id="bgPreviewBtn" class="px-3 py-2 bg-indigo-500 text-white rounded">Preview</button>
                <button id="bgSave" class="px-3 py-2 bg-blue-500 text-white rounded">Save</button>
                <button id="bgCancel" class="px-3 py-2 bg-gray-200 rounded">Cancel</button>
                <button id="bgReset" class="px-3 py-2 bg-red-100 text-red-600 rounded">Reset</button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Add search help modal -->
      <div id="searchHelpModal"
        class="hidden fixed inset-0 bg-black/40 backdrop-blur-xl flex items-center justify-center z-50">
        <div class="bg-white/95 rounded-2xl p-6 w-[500px] shadow-2xl backdrop-blur-xl">
          <h2 class="text-2xl font-bold mb-4 text-white">Search Commands</h2>
          <div class="grid grid-cols-2 gap-4 text-white">
            <div>
              <p><strong>/g</strong> - Google</p>
              <p><strong>/yt</strong> - YouTube</p>
              <p><strong>/gh</strong> - GitHub</p>
              <p><strong>/w</strong> - Wikipedia</p>
              <p><strong>/r</strong> - Reddit</p>
              <p><strong>/so</strong> - Stack Overflow</p>
              <p><strong>/a</strong> - Amazon</p>
              <p><strong>/n</strong> - Netflix</p>
            </div>
            <div>
              <p><strong>/sp</strong> - Spotify</p>
              <p><strong>/tw</strong> - Twitter</p>
              <p><strong>/ig</strong> - Instagram</p>
              <p><strong>/maps</strong> - Google Maps</p>
              <p><strong>/i</strong> - Google Images</p>
              <p><strong>/ddg</strong> - DuckDuckGo</p>
              <p><strong>/px</strong> - Perplexity</p>
            </div>
          </div>
          <div class="text-white/80 text-sm mt-4">
            <p>
              Tip: Use a slash (/) before a command, or just type your search to search with Google
            </p>
          </div>
          <button onclick="closeSearchHelp()" class="mt-6 px-4 py-2 bg-white/20 hover:bg-white/30 rounded text-white">
            Close
          </button>
        </div>
      </div>

      <!-- Create Folder Modal -->
      <div id="createFolderModal" class="hidden fixed inset-0 bg-black/40 backdrop-blur-xl flex items-center justify-center z-50">
        <div class="modal-content bg-white/95 rounded-2xl p-6 w-96 shadow-2xl backdrop-blur-xl">
          <h2 class="text-2xl font-bold mb-4 text-gray-800">Create New Folder</h2>
          <input type="text" id="folderNameInput" placeholder="Folder name" 
                 class="w-full p-3 rounded-xl border-2 border-gray-200 focus:border-blue-400 focus:outline-none mb-4"
                 onkeypress="if(event.key==='Enter') createFolder()"/>
          <div class="flex gap-3">
            <button onclick="createFolder()" 
                    class="flex-1 bg-gradient-to-r from-purple-500 to-pink-500 text-white py-3 rounded-xl hover:shadow-lg transition-all font-medium">
              Create
            </button>
            <button onclick="closeCreateFolderModal()" 
                    class="flex-1 bg-gray-200 text-gray-700 py-3 rounded-xl hover:bg-gray-300 transition-all font-medium">
              Cancel
            </button>
          </div>
        </div>
      </div>

      <!-- Folder Context Menu -->
      <div id="folderContextMenu" class="hidden fixed z-50">
        <div class="bg-white/95 backdrop-blur-xl rounded-xl shadow-2xl overflow-hidden min-w-[200px]">
          <button onclick="renameFolder(document.getElementById('folderContextMenu').getAttribute('data-folder-id'))" 
                  class="w-full px-4 py-3 hover:bg-blue-50 transition-colors text-left flex items-center gap-2">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
            </svg>
            Rename
          </button>
          <button onclick="deleteFolder(document.getElementById('folderContextMenu').getAttribute('data-folder-id'))" 
                  class="w-full px-4 py-3 hover:bg-red-50 transition-colors text-left text-red-600 flex items-center gap-2">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
            </svg>
            Delete Folder
          </button>
        </div>
      </div>

      <!-- Create Folder Modal -->
      <div id="createFolderModal" class="hidden fixed inset-0 bg-black/40 backdrop-blur-xl flex items-center justify-center z-50">
        <div class="modal-content bg-white/95 rounded-2xl p-6 w-96 shadow-2xl backdrop-blur-xl">
          <h2 class="text-2xl font-bold mb-4 text-gray-800">Create New Folder</h2>
          <input type="text" id="folderNameInput" placeholder="Folder name" 
                 class="w-full p-3 rounded-xl border-2 border-gray-200 focus:border-blue-400 focus:outline-none mb-4"
                 onkeypress="if(event.key==='Enter') createFolder()"/>
          <div class="flex gap-3">
            <button onclick="createFolder()" 
                    class="flex-1 bg-gradient-to-r from-purple-500 to-pink-500 text-white py-3 rounded-xl hover:shadow-lg transition-all font-medium">
              Create
            </button>
            <button onclick="closeCreateFolderModal()" 
                    class="flex-1 bg-gray-200 text-gray-700 py-3 rounded-xl hover:bg-gray-300 transition-all font-medium">
              Cancel
            </button>
          </div>
        </div>
      </div>

      <!-- Folder Context Menu -->
      <div id="folderContextMenu" class="hidden fixed z-50">
        <div class="bg-white/95 backdrop-blur-xl rounded-xl shadow-2xl overflow-hidden min-w-[200px]">
          <button onclick="renameFolder(document.getElementById('folderContextMenu').getAttribute('data-folder-id'))" 
                  class="w-full px-4 py-3 hover:bg-blue-50 transition-colors text-left flex items-center gap-2">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
            </svg>
            Rename
          </button>
          <button onclick="deleteFolder(document.getElementById('folderContextMenu').getAttribute('data-folder-id'))" 
                  class="w-full px-4 py-3 hover:bg-red-50 transition-colors text-left text-red-600 flex items-center gap-2">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
            </svg>
            Delete Folder
          </button>
        </div>
      </div>

      <!-- Floating Export/Import Buttons -->
      <!-- Settings Menu -->
      <div class="fixed top-4 right-4 z-50">
        <!-- Settings Button -->
        <button onclick="toggleSettingsMenu()"
          class="group bg-white/20 backdrop-blur-md border border-white/30 hover:bg-white/40 text-white w-12 h-12 min-w-[3rem] min-h-[3rem] rounded-full transition-all duration-300 hover:scale-110 shadow-lg hover:shadow-xl flex items-center justify-center flex-shrink-0"
          title="Settings">
          <svg class="w-5 h-5 transition-transform group-hover:rotate-90" fill="none" stroke="currentColor"
            viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
              d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z">
            </path>
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z">
            </path>
          </svg>
        </button>


        <div id="settingsMenu"
          class="hidden absolute top-14 right-0 bg-white/95 backdrop-blur-xl rounded-2xl shadow-2xl border border-white/20 min-w-[200px] overflow-hidden">
          <div class="py-2">
            <button onclick="exportShortcuts(); toggleSettingsMenu();"
              class="w-full px-4 py-3 text-left hover:bg-white/60 transition-colors flex items-center gap-3">
              <svg class="w-4 h-4 text-white/100" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z">
                </path>
              </svg>
              Export Shortcuts
            </button>

            <button onclick="showImportModal(); toggleSettingsMenu();"
              class="w-full px-4 py-3 text-left hover:bg-white/60 transition-colors flex items-center gap-3">
              <svg class="w-4 h-4 text-white/100" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10"></path>
              </svg>
              Import Shortcuts
            </button>

            <button onclick="openBackgroundModal(); toggleSettingsMenu();"
              class="w-full px-4 py-3 text-left hover:bg-white/60 transition-colors flex items-center gap-3">
              <svg class="w-4 h-4 text-white/100" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536M9 11l6-6m-6 6l-4 4v3h3l4-4"></path>
              </svg>
              Customize Background
            </button>

            <div class="border-t border-gray-200 my-2"></div>

            <button onclick="showAboutModal(); toggleSettingsMenu();"
              class="w-full px-4 py-3 text-left hover:bg-white/60 transition-colors flex items-center gap-3">
              <svg class="w-4 h-4 text-white/100" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
              </svg>
              About
            </button>

            <button onclick="clearAllData(); toggleSettingsMenu();"
              class="w-full px-4 py-3 text-left hover:bg-red-50 text-red-600 transition-colors flex items-center gap-3">
              <svg class="w-4 h-4 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16">
                </path>
              </svg>
              Clear All Data
            </button>
          </div>
        </div>

          <button id="gSuiteToggle" 
            class="bg-white/20 border border-white/30 text-white px-4 py-2 rounded-lg shadow-lg" style="position:fixed; right:80px; top:20px;">G Suite</button>

        <div id="gSuiteBox" class="fixed z-50" style="right: 80px;top: 60px;">
          <div id="googleWorkspaceTools" class="hidden mt-2 bg-white/20 shadow-lg rounded-lg p-4 space-y-2" style="width: 150px;">
            <a href="https://drive.google.com" target="_blank" class="workspace-tool flex items-center space-x-2 bg-bg">
              <img src="google-icons/google-drive.svg" alt="Google Drive" class="h-8 w-8">
              <span>Drive</span>
            </a>
            <a href="https://mail.google.com" target="_blank" class="workspace-tool flex items-center space-x-2 bg-bg">
              <img src="google-icons/gmail.svg" alt="Gmail" class="h-8 w-8">
              <span>Gmail</span>
            </a>
            <a href="https://maps.google.com" target="_blank" class="workspace-tool flex items-center space-x-2 bg-bg">
              <img src="google-icons/google-maps.svg" alt="Google Maps" class="h-8 w-8">
              <span>Maps</span>
            </a>
            <a href="https://docs.google.com" target="_blank" class="workspace-tool flex items-center space-x-2 bg-bg">
              <img src="google-icons/google-docs.svg" alt="Google Docs" class="h-8 w-8">
              <span>Docs</span>
            </a>
            <a href="https://sheets.google.com" target="_blank" class="workspace-tool flex items-center space-x-2 bg-bg">
              <img src="google-icons/google-sheets.svg" alt="Google Sheets" class="h-8 w-8">
              <span>Sheets</span>
            </a>
            <a href="https://slides.google.com" target="_blank" class="workspace-tool flex items-center space-x-2 bg-bg">
              <img src="google-icons/google-slides.svg" alt="Google Slides" class="h-8 w-8">
              <span>Slides</span>
            </a>
            <a href="https://calendar.google.com" target="_blank" class="workspace-tool flex items-center space-x-2 bg-bg">
              <img src="google-icons/google-calendar.svg" alt="Google Calendar" class="h-8 w-8">
              <span>Calendar</span>
            </a>
            <a href="https://meet.google.com" target="_blank" class="workspace-tool flex items-center space-x-2 bg-bg">
              <img src="google-icons/google-meet.svg" alt="Google Meet" class="h-8 w-8">
              <span>Meet</span>
            </a>
          </div>
        </div>

          <script>
            document.addEventListener('DOMContentLoaded', function () {
              const btn = document.getElementById('gSuiteToggle');
              const panel = document.getElementById('googleWorkspaceTools');
              if (!btn || !panel) return;

              let hideTimeout;
              const show = () => {
                clearTimeout(hideTimeout);
                panel.classList.remove('hidden');
              };
              const hide = () => {
                clearTimeout(hideTimeout);
                hideTimeout = setTimeout(() => {
                  panel.classList.add('hidden');
                }, 150);
              };

              // Hover / mouseenter support (prevents flicker when moving between btn and panel)
              btn.addEventListener('mouseenter', show);
              panel.addEventListener('mouseenter', show);
              btn.addEventListener('mouseleave', hide);
              panel.addEventListener('mouseleave', hide);

              // Keep click toggling for accessibility / touch
              btn.addEventListener('click', (e) => {
                panel.classList.toggle('hidden');
                const visible = !panel.classList.contains('hidden');
                e.stopPropagation();
              });

              // Close when clicking outside
              document.addEventListener('click', (e) => {
                if (!btn.contains(e.target) && !panel.contains(e.target)) {
                  panel.classList.add('hidden');
                }
              });

              // Increment counter when a G Suite tool is used and record the click
              try {
                panel.querySelectorAll('.workspace-tool').forEach((a) => {
                  a.addEventListener('click', (e) => {
                    // Increment and update display
                    const updated = typeof incrementSearchCounterSeconds === 'function' ? incrementSearchCounterSeconds(10) : null;
                    // Record the action similar to performSearchRedirect
                    try {
                      const searches = JSON.parse(localStorage.getItem('searches') || '[]');
                      searches.push({ query: a.href || a.getAttribute('href'), time: Date.now(), counterSeconds: updated });
                      localStorage.setItem('searches', JSON.stringify(searches));
                    } catch (err) {
                      localStorage.setItem('searches', JSON.stringify([{ query: a.href || a.getAttribute('href'), time: Date.now(), counterSeconds: updated }]));
                    }
                  });
                });

                // Also support middle-click (wheel click) on G Suite tools
                panel.querySelectorAll('.workspace-tool').forEach((a) => {
                  a.addEventListener('auxclick', (e) => {
                    if (e.button !== 1) return; // only middle click
                    const updated = typeof incrementSearchCounterSeconds === 'function' ? incrementSearchCounterSeconds(10) : null;
                    try {
                      const searches = JSON.parse(localStorage.getItem('searches') || '[]');
                      searches.push({ query: a.href || a.getAttribute('href'), time: Date.now(), counterSeconds: updated });
                      localStorage.setItem('searches', JSON.stringify(searches));
                    } catch (err) {
                      localStorage.setItem('searches', JSON.stringify([{ query: a.href || a.getAttribute('href'), time: Date.now(), counterSeconds: updated }]));
                    }
                    // allow default behavior (open in new tab)
                  });
                });

                // Global delegation: middle-click on any shortcut (and workspace-tool) increments counter
                document.addEventListener('auxclick', (e) => {
                  if (e.button !== 1) return;
                  const anchor = e.target.closest('a[data-position], a.workspace-tool');
                  if (!anchor) return;
                  try {
                    const updated = typeof incrementSearchCounterSeconds === 'function' ? incrementSearchCounterSeconds(10) : null;
                    try {
                      const searches = JSON.parse(localStorage.getItem('searches') || '[]');
                      searches.push({ query: anchor.href || anchor.getAttribute('href'), time: Date.now(), counterSeconds: updated });
                      localStorage.setItem('searches', JSON.stringify(searches));
                    } catch (err) {
                      localStorage.setItem('searches', JSON.stringify([{ query: anchor.href || anchor.getAttribute('href'), time: Date.now(), counterSeconds: updated }]));
                    }
                  } catch (err) {
                    console.warn('Error handling middle-click for shortcuts:', err);
                  }
                });

              } catch (e) {
                // If panel or functions are not available, silently ignore
                console.warn('Could not attach G Suite tool click handlers:', e);
              }
            });
          </script>
  </div>

  <!-- Input file cach√© pour l'import -->
  <input type="file" id="importFileInput" accept=".json" style="display: none;" onchange="handleFileImport(event)">



  <!-- Navigation bar mobile en bas de l'√©cran -->
  <nav id="mobileNavBar" class="fixed bottom-0 left-0 right-0 bg-black/60 backdrop-blur-xl p-2 z-50 lg:hidden">
    <div class="flex justify-center items-center">
      <div class="flex items-center gap-5">
        <button id="showSidebar"
          class="flex flex-col items-center py-1 px-3 text-white/80 hover:text-white transition-colors rounded-xl">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
              d="M5 12h.01M12 12h.01M19 12h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z">
            </path>
          </svg>
          <span class="text-xs">Quick Access</span>
        </button>
        <button onclick="showSearchHelp()"
          class="mr-2 flex flex-col items-center py-1 px-3 text-white/80 hover:text-white transition-colors rounded-xl">
          <span class="text-xl font-medium w-6 h-6 flex items-center justify-center">?</span>
          <span class="text-xs">Help Center</span>
        </button>
      </div>
    </div>
  </nav>

  <!-- Ajout d'un modal pour afficher la sidebar sur mobile -->
  <div id="sidebarModal" class="fixed inset-0 bg-black/40 backdrop-blur-md z-[60] hidden">
    <div
      class="fixed bottom-0 inset-x-0 rounded-t-3xl bg-white/90 backdrop-blur-xl p-6 shadow-2xl max-h-[80vh] overflow-y-auto scrollbar-hide transition-transform duration-300 transform translate-y-0">
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-xl font-medium text-white">Quick Access</h2>
        <button id="closeSidebar" class="p-2 text-white rounded-full bg-white/20 hover:bg-white/30">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>
      <div id="sidebarContent" class="space-y-4">
        <!-- Le contenu de la sidebar sera clon√© ici via JavaScript -->
      </div>
    </div>
  </div>

  <!-- Ajout des styles pour le menu mobile -->
  <style>
    /* Hide scrollbar for sidebar */
    .scrollbar-hide {
      /* Firefox */
      scrollbar-width: none;
    }

    .scrollbar-hide::-webkit-scrollbar {
      /* Chrome, Safari and Opera */
      display: none;
    }

    @media (min-width: 1024px) {
      main {
        margin-left: 0 !important;
      }
    }

    /* Add these new styles for the tooltip */
    .shortcut-container {
      position: relative;
    }

    .shortcut-container::before {
      content: "Right-click to edit or delete";
      position: absolute;
      top: -30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.2s ease;
      pointer-events: none;
      white-space: nowrap;
      backdrop-filter: blur(4px);
    }

    .shortcut-container:hover::before {
      opacity: 1;
    }

    /* Preview overlay styles */
    #backgroundPreviewOverlay {
      position: fixed;
      inset: 0;
      z-index: 99999;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      background: rgba(0,0,0,0.08);
    }

    #backgroundPreviewOverlay .preview-border {
      position: absolute;
      inset: 0;
      box-sizing: border-box;
      border: 12px solid rgba(0,0,0,0.45);
      border-radius: 8px;
      pointer-events: none;
      mix-blend-mode: normal;
    }

    #backgroundPreviewOverlay .preview-hint {
      position: absolute;
      top: 18px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: 600;
      z-index: 100000;
    }

    #backgroundPreviewOverlay .preview-bg {
      position: absolute;
      inset: 0;
      z-index: 99998;
      background-position: center center;
      background-repeat: no-repeat;
      background-size: cover;
      transition: filter 160ms ease, background-size 160ms ease;
    }

    /* Gradient direction buttons */
    .gradient-dir-btn {
      --dir-bg: #f8fafc;
      --dir-hover-bg: #e2e8f0;
      --dir-active-bg: #e0f2fe;
      --dir-ring: rgba(96,165,250,0.32);
      --dir-color: #1d4ed8;
      width: 38px;
      height: 38px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      background: var(--dir-bg);
      color: var(--dir-color);
      transition: all 120ms ease;
      box-shadow: 0 1px 2px rgba(0,0,0,0.06);
    }

    .gradient-dir-btn:hover {
      border-color: #cbd5e1;
      background: var(--dir-hover-bg);
    }

    .gradient-dir-btn.active {
      border-color: var(--dir-color);
      background: var(--dir-active-bg);
      color: var(--dir-color);
      box-shadow: 0 0 0 2px var(--dir-ring);
    }

    .gradient-dir-btn[data-dir="to right"] { --dir-bg: #e0f2fe; --dir-hover-bg: #dbeafe; --dir-active-bg: #bfdbfe; --dir-ring: rgba(59,130,246,0.28); --dir-color: #1d4ed8; }
    .gradient-dir-btn[data-dir="to left"] { --dir-bg: #e0f7ff; --dir-hover-bg: #bae6fd; --dir-active-bg: #7dd3fc; --dir-ring: rgba(14,165,233,0.28); --dir-color: #0369a1; }
    .gradient-dir-btn[data-dir="to top"] { --dir-bg: #fef9c3; --dir-hover-bg: #fef08a; --dir-active-bg: #fde047; --dir-ring: rgba(234,179,8,0.28); --dir-color: #b45309; }
    .gradient-dir-btn[data-dir="to bottom"] { --dir-bg: #dcfce7; --dir-hover-bg: #bbf7d0; --dir-active-bg: #86efac; --dir-ring: rgba(34,197,94,0.28); --dir-color: #15803d; }
    .gradient-dir-btn[data-dir="to top left"] { --dir-bg: #ede9fe; --dir-hover-bg: #ddd6fe; --dir-active-bg: #c4b5fd; --dir-ring: rgba(124,58,237,0.28); --dir-color: #6d28d9; }
    .gradient-dir-btn[data-dir="to top right"] { --dir-bg: #fee2e2; --dir-hover-bg: #fecdd3; --dir-active-bg: #fda4af; --dir-ring: rgba(248,113,113,0.28); --dir-color: #b91c1c; }
    .gradient-dir-btn[data-dir="to bottom left"] { --dir-bg: #cffafe; --dir-hover-bg: #a5f3fc; --dir-active-bg: #67e8f9; --dir-ring: rgba(14,165,233,0.28); --dir-color: #0f766e; }
    .gradient-dir-btn[data-dir="to bottom right"] { --dir-bg: #fce7f3; --dir-hover-bg: #fbcfe8; --dir-active-bg: #f9a8d4; --dir-ring: rgba(236,72,153,0.28); --dir-color: #be185d; }

    /* Styles for custom background and preview */
    #customBackground {
      position: fixed;
      inset: 0;
      z-index: -10;
      pointer-events: none;
      background-position: center center;
      background-repeat: no-repeat;
      background-size: cover;
      transition: filter 180ms ease, background-size 180ms ease, opacity 200ms ease;
      filter: blur(0px);
      opacity: 1;
    }

    #bgPreview {
      background-position: center center;
      background-size: cover;
    }

    /* Animation for save city button suggestion */
    @keyframes pulse {

      0%,
      100% {
        transform: scale(1);
        opacity: 1;
      }

      50% {
        transform: scale(1.05);
        opacity: 0.8;
      }
    }
  </style>

  <!-- Script pour cloner le contenu de la sidebar dans le modal mobile -->
  <script>
    // Function to validate and clean localStorage for weather data
    function validateWeatherStorage() {
      let storageAvailable = false;

      try {
        // Test if localStorage is available
        const testKey = 'test_weather_storage';
        localStorage.setItem(testKey, 'test');
        localStorage.removeItem(testKey);
        storageAvailable = true;

        // Validate existing weather city data
        const savedCity = localStorage.getItem('lastWeatherCity');
        if (savedCity !== null) {
          // Clean up any invalid data (empty strings, just whitespace, etc.)
          if (typeof savedCity !== 'string' || savedCity.trim() === '') {
            localStorage.removeItem('lastWeatherCity');
            console.log('Removed invalid weather city data from localStorage');
          }
        }
      } catch (error) {
        console.error('localStorage is not available or corrupted:', error);
        storageAvailable = false;

        // Try cookies as fallback
        try {
          document.cookie = 'test_weather_cookie=test; max-age=1; path=/';
          const testRead = document.cookie.includes('test_weather_cookie=test');
          if (testRead) {
            console.log('Using cookies as fallback for weather data storage');
            // Clean expired test cookie
            document.cookie = 'test_weather_cookie=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/';
          }
        } catch (cookieError) {
          console.error('Cookies are also not available:', cookieError);
        }
      }

      return storageAvailable;
    }

    document.addEventListener("DOMContentLoaded", function () {
      // Validate localStorage before using it
      const storageAvailable = validateWeatherStorage();      // Clone sidebar content for mobile modal
      const sidebarChildren = document.querySelectorAll(
        "#sidebar > *:not(:first-child)"
      );
      const sidebarContent = document.getElementById("sidebarContent");

      sidebarChildren.forEach((child) => {
        sidebarContent.appendChild(child.cloneNode(true));
      });

      // Modal display management
      const showSidebarBtn = document.getElementById("showSidebar");
      const closeSidebarBtn = document.getElementById("closeSidebar");
      const sidebarModal = document.getElementById("sidebarModal");

      showSidebarBtn.addEventListener("click", function () {
        sidebarModal.classList.remove("hidden");
        document.body.style.overflow = "hidden"; // Prevent body scrolling
      });

      closeSidebarBtn.addEventListener("click", function () {
        sidebarModal.classList.add("hidden");
        document.body.style.overflow = ""; // Re-enable scrolling
      });

      // Close modal if clicked outside content
      sidebarModal.addEventListener("click", function (e) {
        if (e.target === sidebarModal) {
          sidebarModal.classList.add("hidden");
          document.body.style.overflow = "";
        }
      });

      // Check if there's a saved city and load its weather, otherwise show input
      // This will work with either localStorage or cookies fallback
      const savedCity = getWeatherCity();
      if (savedCity) {
        document.getElementById('weather-city-input').value = savedCity;
        loadWeather(savedCity);
      }

      // Initialize saved cities display
      updateSavedCitiesDisplay();
    });

    // Weather Widget Functions

    // Helper function to safely save to localStorage
    function saveWeatherCity(cityName) {
      if (!cityName || typeof cityName !== 'string' || cityName.trim() === '') {
        console.warn('Invalid city name provided for saving');
        return false;
      }

      try {
        localStorage.setItem('lastWeatherCity', cityName.trim());
        return true;
      } catch (error) {
        console.error('Error saving city to localStorage, trying cookies fallback:', error);
        // Fallback to cookies if localStorage is not available
        try {
          document.cookie = `lastWeatherCity=${encodeURIComponent(cityName.trim())}; max-age=2592000; path=/`; // 30 days
          return true;
        } catch (cookieError) {
          console.error('Error saving city to cookies:', cookieError);
          return false;
        }
      }
    }

    // Helper function to safely read from localStorage
    function getWeatherCity() {
      try {
        const savedCity = localStorage.getItem('lastWeatherCity');
        if (savedCity && typeof savedCity === 'string' && savedCity.trim() !== '') {
          return savedCity.trim();
        }
      } catch (error) {
        console.error('Error reading city from localStorage, trying cookies fallback:', error);
      }

      // Fallback to cookies
      try {
        const cookieValue = document.cookie.split('; ')
          .find(row => row.startsWith('lastWeatherCity='));
        if (cookieValue) {
          const cityName = decodeURIComponent(cookieValue.split('=')[1]);
          if (cityName && cityName.trim() !== '') {
            return cityName.trim();
          }
        }
      } catch (cookieError) {
        console.error('Error reading city from cookies:', cookieError);
      }

      return null;
    }

    // Functions for managing saved cities
    function getSavedCities() {
      try {
        const savedCities = localStorage.getItem('savedWeatherCities');
        if (savedCities) {
          return JSON.parse(savedCities);
        }
      } catch (error) {
        console.error('Error reading saved cities from localStorage, trying cookies:', error);
        try {
          const cookieValue = document.cookie.split('; ')
            .find(row => row.startsWith('savedWeatherCities='));
          if (cookieValue) {
            return JSON.parse(decodeURIComponent(cookieValue.split('=')[1]));
          }
        } catch (cookieError) {
          console.error('Error reading saved cities from cookies:', cookieError);
        }
      }
      return [];
    }

    function saveCitiesList(cities) {
      try {
        localStorage.setItem('savedWeatherCities', JSON.stringify(cities));
        return true;
      } catch (error) {
        console.error('Error saving cities to localStorage, trying cookies:', error);
        try {
          document.cookie = `savedWeatherCities=${encodeURIComponent(JSON.stringify(cities))}; max-age=2592000; path=/`;
          return true;
        } catch (cookieError) {
          console.error('Error saving cities to cookies:', cookieError);
          return false;
        }
      }
    }

    function saveCurrentCity() {
      const cityInput = document.getElementById('weather-city-input');
      const cityName = cityInput.value.trim();

      if (!cityName) {
        alert('Please enter a city name first');
        return;
      }

      const savedCities = getSavedCities();

      // Check if city is already saved (case insensitive)
      const cityExists = savedCities.some(city =>
        city.toLowerCase() === cityName.toLowerCase()
      );

      if (cityExists) {
        alert('This city is already saved');
        return;
      }

      // Limit to 5 saved cities
      if (savedCities.length >= 5) {
        alert('Maximum 5 cities can be saved. Please remove one first.');
        return;
      }

      savedCities.push(cityName);
      saveCitiesList(savedCities);
      updateSavedCitiesDisplay();

      // Show confirmation
      const saveButton = event.target;
      const originalText = saveButton.innerHTML;
      const originalBg = saveButton.style.backgroundColor;
      saveButton.innerHTML = '‚úÖ';
      saveButton.style.backgroundColor = 'rgba(34, 197, 94, 0.8)';
      setTimeout(() => {
        saveButton.innerHTML = originalText;
        saveButton.style.backgroundColor = originalBg;
      }, 1500);
    }

    function loadSavedCity(cityName) {
      document.getElementById('weather-city-input').value = cityName;
      loadWeather(cityName);
    }

    function removeSavedCity(cityName) {
      if (!confirm(`Remove "${cityName}" from saved cities?`)) {
        return;
      }

      const savedCities = getSavedCities();
      const filteredCities = savedCities.filter(city => city !== cityName);
      saveCitiesList(filteredCities);
      updateSavedCitiesDisplay();
    }

    function updateSavedCitiesDisplay() {
      const savedCitiesList = document.getElementById('saved-cities-list');
      const savedCitiesContainer = document.getElementById('saved-cities');
      const citiesCount = document.getElementById('cities-count');
      const savedCities = getSavedCities();

      if (savedCities.length === 0) {
        savedCitiesContainer.style.display = 'none';
        return;
      }

      savedCitiesContainer.style.display = 'block';
      citiesCount.textContent = `${savedCities.length}/5`;
      savedCitiesList.innerHTML = '';

      savedCities.forEach(city => {
        const cityContainer = document.createElement('div');
        cityContainer.className = 'group relative inline-flex items-center px-2 py-1 bg-white/20 hover:bg-white/30 rounded text-xs text-white transition-colors mr-1 mb-1 cursor-pointer';

        const citySpan = document.createElement('span');
        citySpan.textContent = city;
        citySpan.className = 'select-none';

        const removeButton = document.createElement('button');
        removeButton.textContent = '√ó';
        removeButton.className = 'ml-1 opacity-0 group-hover:opacity-100 text-red-300 hover:text-red-100 transition-opacity text-sm font-bold';
        removeButton.title = 'Remove city';
        removeButton.onclick = (e) => {
          e.stopPropagation();
          removeSavedCity(city);
        };

        cityContainer.onclick = () => loadSavedCity(city);
        cityContainer.appendChild(citySpan);
        cityContainer.appendChild(removeButton);
        savedCitiesList.appendChild(cityContainer);
      });
    }

    function suggestSavingCity(cityName) {
      const savedCities = getSavedCities();

      // Don't suggest if already saved or if we have max cities
      if (savedCities.includes(cityName) || savedCities.length >= 5) {
        return;
      }

      // Show a subtle suggestion (could be a toast notification)
      const saveButton = document.querySelector('button[onclick="saveCurrentCity()"]');
      if (saveButton) {
        saveButton.style.animation = 'pulse 2s infinite';
        saveButton.title = `Save "${cityName}" to favorites`;

        // Remove animation after 5 seconds
        setTimeout(() => {
          saveButton.style.animation = '';
          saveButton.title = 'Save current city';
        }, 5000);
      }
    }

    function getWeatherIcon(weatherCode, isDay) {
      const iconMap = {
        0: { day: '<img src="sunny.png" alt="Sunny" class="w-16 h-16 mx-auto" />', night: 'üåô' }, // Clear sky
        1: { day: '<img src="sunny.png" alt="Mostly Sunny" class="w-16 h-16 mx-auto" />', night: 'üåô' }, // Mainly clear
        2: { day: '<img src="cloudy.png" alt="Partly Cloudy" class="w-16 h-16 mx-auto" />', night: '<img src="cloudy.png" alt="Cloudy" class="w-16 h-16 mx-auto" />' }, // Partly cloudy
        3: { day: '<img src="cloudy.png" alt="Overcast" class="w-16 h-16 mx-auto" />', night: '<img src="cloudy.png" alt="Overcast" class="w-16 h-16 mx-auto" />' }, // Overcast
        45: { day: 'üå´Ô∏è', night: 'üå´Ô∏è' }, // Fog
        48: { day: 'üå´Ô∏è', night: 'üå´Ô∏è' }, // Depositing rime fog
        51: { day: 'üå¶Ô∏è', night: 'üåßÔ∏è' }, // Light drizzle
        53: { day: 'üå¶Ô∏è', night: 'üåßÔ∏è' }, // Moderate drizzle
        55: { day: 'üåßÔ∏è', night: 'üåßÔ∏è' }, // Dense drizzle
        61: { day: 'üåßÔ∏è', night: 'üåßÔ∏è' }, // Slight rain
        63: { day: 'üåßÔ∏è', night: 'üåßÔ∏è' }, // Moderate rain
        65: { day: 'üåßÔ∏è', night: 'üåßÔ∏è' }, // Heavy rain
        71: { day: 'üå®Ô∏è', night: 'üå®Ô∏è' }, // Slight snow
        73: { day: 'üå®Ô∏è', night: 'üå®Ô∏è' }, // Moderate snow
        75: { day: '‚ùÑÔ∏è', night: '‚ùÑÔ∏è' }, // Heavy snow
        77: { day: '‚ùÑÔ∏è', night: '‚ùÑÔ∏è' }, // Snow grains
        80: { day: 'üå¶Ô∏è', night: 'üåßÔ∏è' }, // Slight rain showers
        81: { day: 'üåßÔ∏è', night: 'üåßÔ∏è' }, // Moderate rain showers
        82: { day: '‚õàÔ∏è', night: '‚õàÔ∏è' }, // Violent rain showers
        85: { day: 'üå®Ô∏è', night: 'üå®Ô∏è' }, // Slight snow showers
        86: { day: '‚ùÑÔ∏è', night: '‚ùÑÔ∏è' }, // Heavy snow showers
        95: { day: '‚õàÔ∏è', night: '‚õàÔ∏è' }, // Thunderstorm
        96: { day: '‚õàÔ∏è', night: '‚õàÔ∏è' }, // Thunderstorm with slight hail
        99: { day: '‚õàÔ∏è', night: '‚õàÔ∏è' }, // Thunderstorm with heavy hail
      };

      const icons = iconMap[weatherCode] || { day: '‚ùì', night: '‚ùì' };
      return isDay ? icons.day : icons.night;
    }

    // Helper function to get icon for forecast cards (smaller size)
    function getWeatherIconSmall(weatherCode, isDay) {
      const iconMap = {
        0: { day: '<img src="sunny.png" alt="Sunny" class="w-8 h-8" />', night: 'üåô' }, // Clear sky
        1: { day: '<img src="sunny.png" alt="Mostly Sunny" class="w-8 h-8" />', night: 'üåô' }, // Mainly clear
        2: { day: '<img src="cloudy.png" alt="Partly Cloudy" class="w-8 h-8" />', night: '<img src="cloudy.png" alt="Cloudy" class="w-8 h-8" />' }, // Partly cloudy
        3: { day: '<img src="cloudy.png" alt="Overcast" class="w-8 h-8" />', night: '<img src="cloudy.png" alt="Overcast" class="w-8 h-8" />' }, // Overcast
        45: { day: 'üå´Ô∏è', night: 'üå´Ô∏è' }, // Fog
        48: { day: 'üå´Ô∏è', night: 'üå´Ô∏è' }, // Depositing rime fog
        51: { day: 'üå¶Ô∏è', night: 'üåßÔ∏è' }, // Light drizzle
        53: { day: 'üå¶Ô∏è', night: 'üåßÔ∏è' }, // Moderate drizzle
        55: { day: 'üåßÔ∏è', night: 'üåßÔ∏è' }, // Dense drizzle
        61: { day: 'üåßÔ∏è', night: 'üåßÔ∏è' }, // Slight rain
        63: { day: 'üåßÔ∏è', night: 'üåßÔ∏è' }, // Moderate rain
        65: { day: 'üåßÔ∏è', night: 'üåßÔ∏è' }, // Heavy rain
        71: { day: 'üå®Ô∏è', night: 'üå®Ô∏è' }, // Slight snow
        73: { day: 'üå®Ô∏è', night: 'üå®Ô∏è' }, // Moderate snow
        75: { day: '‚ùÑÔ∏è', night: '‚ùÑÔ∏è' }, // Heavy snow
        77: { day: '‚ùÑÔ∏è', night: '‚ùÑÔ∏è' }, // Snow grains
        80: { day: 'üå¶Ô∏è', night: 'üåßÔ∏è' }, // Slight rain showers
        81: { day: 'üåßÔ∏è', night: 'üåßÔ∏è' }, // Moderate rain showers
        82: { day: '‚õàÔ∏è', night: '‚õàÔ∏è' }, // Violent rain showers
        85: { day: 'üå®Ô∏è', night: 'üå®Ô∏è' }, // Slight snow showers
        86: { day: '‚ùÑÔ∏è', night: '‚ùÑÔ∏è' }, // Heavy snow showers
        95: { day: '‚õàÔ∏è', night: '‚õàÔ∏è' }, // Thunderstorm
        96: { day: '‚õàÔ∏è', night: '‚õàÔ∏è' }, // Thunderstorm with slight hail
        99: { day: '‚õàÔ∏è', night: '‚õàÔ∏è' }, // Thunderstorm with heavy hail
      };

      const icons = iconMap[weatherCode] || { day: '‚ùì', night: '‚ùì' };
      return isDay ? icons.day : icons.night;
    }

    function getWeatherDescription(weatherCode) {
      const descriptions = {
        0: 'Clear sky',
        1: 'Mainly clear',
        2: 'Partly cloudy',
        3: 'Overcast',
        45: 'Fog',
        48: 'Depositing rime fog',
        51: 'Light drizzle',
        53: 'Moderate drizzle',
        55: 'Dense drizzle',
        61: 'Slight rain',
        63: 'Moderate rain',
        65: 'Heavy rain',
        71: 'Slight snow fall',
        73: 'Moderate snow fall',
        75: 'Heavy snow fall',
        77: 'Snow grains',
        80: 'Slight rain showers',
        81: 'Moderate rain showers',
        82: 'Violent rain showers',
        85: 'Slight snow showers',
        86: 'Heavy snow showers',
        95: 'Thunderstorm',
        96: 'Thunderstorm with slight hail',
        99: 'Thunderstorm with heavy hail'
      };

      return descriptions[weatherCode] || 'Unknown';
    }

    function updateWeatherForecast(daily) {
      const forecastContainer = document.getElementById('weather-forecast');
      if (!forecastContainer) return;

      // Clear existing forecast
      forecastContainer.innerHTML = '';

      // Create forecast items for the next few days (skip today, start from tomorrow)
      for (let i = 1; i < Math.min(daily.time.length, 3); i++) {
        const date = new Date(daily.time[i]);
        const dayName = date.toLocaleDateString('en-US', { weekday: 'long' });
        const weatherCode = daily.weather_code[i];
        const maxTemp = Math.round(daily.temperature_2m_max[i]);
        const minTemp = Math.round(daily.temperature_2m_min[i]);
        const icon = getWeatherIconSmall(weatherCode, true); // Use day icon for forecast with smaller size
        const description = getWeatherDescription(weatherCode);

        const forecastItem = document.createElement('div');
        forecastItem.className = 'flex items-center justify-start bg-white/20 rounded-lg p-3';
        forecastItem.innerHTML = `
          <div class="flex items-center gap-3">
            <span class="text-2xl flex items-center">${icon}</span>
            <div class="text-left">
              <div class="text-white font-medium">${dayName} - ${description}</div>
              <div class="text-white/70 text-sm">Max ${maxTemp}¬∞C Min ${minTemp}¬∞C</div>
            </div>
          </div>
        `;

        forecastContainer.appendChild(forecastItem);
      }
    }

    async function loadWeather(cityName) {
      const weatherInput = document.getElementById('weather-input');
      const weatherLoading = document.getElementById('weather-loading');
      const weatherContent = document.getElementById('weather-content');
      const weatherError = document.getElementById('weather-error');

      // Show loading state
      weatherInput.classList.add('hidden');
      weatherLoading.classList.remove('hidden');
      weatherContent.classList.add('hidden');
      weatherError.classList.add('hidden');

      try {
        // Get coordinates for the city using a geocoding API
        const geocodeResponse = await fetch(
          `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(cityName)}&format=json&limit=1`
        );

        let latitude, longitude, locationDisplayName, countryName;

        if (geocodeResponse.ok) {
          const geocodeData = await geocodeResponse.json();
          if (geocodeData.length > 0) {
            latitude = parseFloat(geocodeData[0].lat);
            longitude = parseFloat(geocodeData[0].lon);
            const addressParts = geocodeData[0].display_name.split(',');
            locationDisplayName = addressParts[0].trim();

            // Try to extract country from address
            const address = geocodeData[0].address || {};
            countryName = address.country || addressParts[addressParts.length - 1].trim();
          } else {
            throw new Error('City not found');
          }
        } else {
          throw new Error('Unable to find city coordinates');
        }

        // Fetch weather data with forecast using Open-Meteo API
        const weatherResponse = await fetch(
          `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,relative_humidity_2m,apparent_temperature,is_day,weather_code,wind_speed_10m,visibility&daily=weather_code,temperature_2m_max,temperature_2m_min&timezone=auto&forecast_days=3`
        );

        if (!weatherResponse.ok) {
          throw new Error('Weather API request failed');
        }

        const weatherData = await weatherResponse.json();
        const current = weatherData.current;
        const daily = weatherData.daily;

        // Update weather display
        const isDay = current.is_day === 1;
        const weatherIcon = getWeatherIcon(current.weather_code, isDay);
        const weatherDescription = getWeatherDescription(current.weather_code);

        // Update main weather info
        document.getElementById('weather-city-name').textContent = locationDisplayName.toUpperCase();
        document.getElementById('weather-icon').innerHTML = weatherIcon;
        document.getElementById('weather-temp').textContent = `${Math.round(current.temperature_2m)}¬∞C`;
        document.getElementById('weather-location').textContent = `${locationDisplayName}, ${countryName}`;
        document.getElementById('weather-description').textContent = weatherDescription;

        // Update forecast
        updateWeatherForecast(daily);

        // Save the city name for future use - only save if weather loaded successfully
        saveWeatherCity(cityName);

        // Check if we should suggest saving this city
        suggestSavingCity(locationDisplayName);

        // Show content
        weatherLoading.classList.add('hidden');
        weatherContent.classList.remove('hidden');

      } catch (error) {
        console.error('Error loading weather:', error);
        weatherLoading.classList.add('hidden');
        weatherError.classList.remove('hidden');
      }
    }

    function showCityInput() {
      document.getElementById('weather-input').classList.remove('hidden');
      document.getElementById('weather-loading').classList.add('hidden');
      document.getElementById('weather-content').classList.add('hidden');
      document.getElementById('weather-error').classList.add('hidden');
      document.getElementById('weather-city-input').focus();
    }

    function loadWeatherForCity() {
      const cityInput = document.getElementById('weather-city-input');
      const cityName = cityInput.value.trim();

      if (!cityName) {
        alert('Please enter a city name');
        return;
      }

      // Save the city name immediately when user requests it
      saveWeatherCity(cityName);

      loadWeather(cityName);
    }

    // Notes Widget Functions
    function showAddNoteForm() {
      document.getElementById('add-note-form').classList.remove('hidden');
      document.getElementById('note-text').focus();
    }

    function hideAddNoteForm() {
      document.getElementById('add-note-form').classList.add('hidden');
      document.getElementById('note-text').value = '';
    }

    function addNote(color) {
      const noteText = document.getElementById('note-text').value.trim();
      if (!noteText) {
        alert('Please enter some text for your note');
        return;
      }

      const notes = JSON.parse(localStorage.getItem('userNotes') || '[]');
      const newNote = {
        id: Date.now(),
        text: noteText,
        color: color,
        createdAt: new Date().toISOString()
      };

      notes.push(newNote);
      localStorage.setItem('userNotes', JSON.stringify(notes));

      hideAddNoteForm();
      loadNotes();
    }

    function deleteNote(noteId) {
      const notes = JSON.parse(localStorage.getItem('userNotes') || '[]');
      const filteredNotes = notes.filter(note => note.id !== noteId);
      localStorage.setItem('userNotes', JSON.stringify(filteredNotes));
      loadNotes();
    }

    function editNote(noteId) {
      const notes = JSON.parse(localStorage.getItem('userNotes') || '[]');
      const note = notes.find(n => n.id === noteId);
      if (!note) return;

      const newText = prompt('Edit your note:', note.text);
      if (newText === null) return; // User cancelled

      if (newText.trim() === '') {
        if (confirm('Delete this note?')) {
          deleteNote(noteId);
        }
        return;
      }

      note.text = newText.trim();
      localStorage.setItem('userNotes', JSON.stringify(notes));
      loadNotes();
    }

    function getColorClasses(color) {
      const colorMap = {
        yellow: 'bg-yellow-200 text-yellow-900 border-yellow-300',
        green: 'bg-green-200 text-green-900 border-green-300',
        pink: 'bg-pink-200 text-pink-900 border-pink-300',
        blue: 'bg-blue-200 text-blue-900 border-blue-300'
      };
      return colorMap[color] || colorMap.yellow;
    }

    function getRandomRotation() {
      // Random rotation between -3 and 3 degrees
      const rotation = (Math.random() - 0.5) * 6;
      return `transform: rotate(${rotation}deg);`;
    }

    function getRandomBorderRadius() {
      // Create slightly irregular border radius for organic look
      const tl = Math.random() * 5 + 10; // 10-15px
      const tr = Math.random() * 5 + 10; // 10-15px
      const br = Math.random() * 5 + 10; // 10-15px
      const bl = Math.random() * 5 + 10; // 10-15px
      return `border-radius: ${tl}px ${tr}px ${bl}px;`;
    }

    function getDynamicFontSize(text) {
      const textLength = text.length;

      // Define font size ranges based on text length - MUCH larger sizes for short text
      if (textLength <= 2) {
        return 'text-9xl'; // Massive font for 1-2 characters (128px)
      } else if (textLength <= 4) {
        return 'text-8xl'; // Huge font for 3-4 characters (96px)
      } else if (textLength <= 6) {
        return 'text-7xl'; // Very huge font for 5-6 characters (72px)
      } else if (textLength <= 8) {
        return 'text-6xl'; // Extra large font for 7-8 characters (60px)
      } else if (textLength <= 12) {
        return 'text-5xl'; // Large font for short words (48px)
      } else if (textLength <= 18) {
        return 'text-4xl'; // Medium-large font (36px)
      } else if (textLength <= 25) {
        return 'text-3xl'; // Large font (30px)
      } else if (textLength <= 35) {
        return 'text-2xl'; // Medium font (24px)
      } else if (textLength <= 50) {
        return 'text-xl'; // Medium-small font (20px)
      } else if (textLength <= 70) {
        return 'text-lg'; // Small font (18px)
      } else if (textLength <= 100) {
        return 'text-base'; // Standard font (16px)
      } else if (textLength <= 150) {
        return 'text-sm'; // Small font (14px)
      } else {
        return 'text-xs'; // Extra small font for very long text (12px)
      }
    }

    function getDynamicLineHeight(text) {
      const textLength = text.length;

      // Adjust line height based on text length for better readability
      if (textLength <= 2) {
        return 'leading-none'; // Very tight line height for massive text
      } else if (textLength <= 4) {
        return 'leading-tight'; // Tight line height for huge text
      } else if (textLength <= 6) {
        return 'leading-tight'; // Tight line height for very large text
      } else if (textLength <= 8) {
        return 'leading-snug'; // Snug line height for extra large text
      } else if (textLength <= 12) {
        return 'leading-snug'; // Snug line height for large text
      } else if (textLength <= 18) {
        return 'leading-normal'; // Normal line height for medium-large text
      } else if (textLength <= 25) {
        return 'leading-normal'; // Normal line height
      } else if (textLength <= 35) {
        return 'leading-normal'; // Normal line height
      } else {
        return 'leading-relaxed'; // More relaxed line height for longer text
      }
    }

    function getDynamicPadding(text) {
      const textLength = text.length;

      // Adjust padding based on text length to optimize space usage
      if (textLength <= 2) {
        return 'p-8'; // Maximum padding for massive text (1-2 chars)
      } else if (textLength <= 4) {
        return 'p-7'; // Large padding for huge text (3-4 chars)
      } else if (textLength <= 6) {
        return 'p-6'; // Extra padding for very large text (5-6 chars)
      } else if (textLength <= 8) {
        return 'p-6'; // Extra padding for large text (7-8 chars)
      } else if (textLength <= 12) {
        return 'p-5'; // More padding for medium-large text
      } else if (textLength <= 18) {
        return 'p-4'; // Good padding for medium text
      } else if (textLength <= 35) {
        return 'p-4'; // Standard padding for medium-long text
      } else if (textLength <= 70) {
        return 'p-3'; // Standard padding
      } else {
        return 'p-2'; // Less padding for long text to save space
      }
    }

    function getRandomNoteStyle() {
      return `${getRandomRotation()} ${getRandomBorderRadius()}`;
    }

    function loadNotes() {
      const notes = JSON.parse(localStorage.getItem('userNotes') || '[]');
      const container = document.getElementById('notes-container');
      const emptyState = document.getElementById('notes-empty');

      if (notes.length === 0) {
        container.classList.add('hidden');
        emptyState.classList.remove('hidden');
        return;
      }

      container.classList.remove('hidden');
      emptyState.classList.add('hidden');

      // Sort notes by creation date (newest first)
      notes.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

      container.innerHTML = notes.map(note => `
        <div class="relative ${getColorClasses(note.color)} ${getDynamicPadding(note.text)} border-2 shadow-sm font-patrick transition-transform hover:scale-105 hover:z-10" 
             style="${getRandomNoteStyle()}">
          <div class="${getDynamicFontSize(note.text)} ${getDynamicLineHeight(note.text)} break-words">${escapeHtml(note.text)}</div>
          <div class="flex justify-end gap-1 mt-2">
            <button onclick="editNote(${note.id})" 
                    class="p-1 rounded hover:bg-black/10 transition-colors"
                    title="Edit note">
              <svg class="w-3 h-3 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                      d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
              </svg>
            </button>
            <button onclick="deleteNote(${note.id})" 
                    class="p-1 rounded hover:bg-red-500/20 transition-colors text-red-600"
                    title="Delete note">
              <svg class="w-3 h-3 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                      d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
              </svg>
            </button>
          </div>
        </div>
      `).join('');
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Load notes on page load
    document.addEventListener('DOMContentLoaded', function () {
      // Load notes after other initialization
      setTimeout(() => {
        loadNotes();
        loadPomodoroStats();
      }, 100);
    });

    // ==================== POMODORO FUNCTIONALITY ====================

    let pomodoroState = {
      isRunning: false,
      isPaused: false,
      currentTime: 25 * 60, // 25 minutes in seconds
      totalTime: 25 * 60,
      mode: 'focus', // 'focus', 'break', 'longBreak'
      session: 1,
      totalSessions: 4,
      timer: null,
      settings: {
        focusTime: 25,
        breakTime: 5,
        longBreakTime: 15
      }
    };

    function startPomodoro() {
      if (!pomodoroState.isRunning) {
        pomodoroState.isRunning = true;
        pomodoroState.isPaused = false;

        document.getElementById('pomodoro-start').classList.add('hidden');
        document.getElementById('pomodoro-pause').classList.remove('hidden');

        pomodoroState.timer = setInterval(updateTimer, 1000);

        // Play start sound (optional)
        playPomodoroSound('start');
      }
    }

    function pausePomodoro() {
      if (pomodoroState.isRunning) {
        pomodoroState.isRunning = false;
        pomodoroState.isPaused = true;

        clearInterval(pomodoroState.timer);

        document.getElementById('pomodoro-start').classList.remove('hidden');
        document.getElementById('pomodoro-pause').classList.add('hidden');
      }
    }

    function resetPomodoro() {
      clearInterval(pomodoroState.timer);
      pomodoroState.isRunning = false;
      pomodoroState.isPaused = false;

      // Reset to current mode's default time
      if (pomodoroState.mode === 'focus') {
        pomodoroState.currentTime = pomodoroState.settings.focusTime * 60;
        pomodoroState.totalTime = pomodoroState.settings.focusTime * 60;
      } else if (pomodoroState.mode === 'break') {
        pomodoroState.currentTime = pomodoroState.settings.breakTime * 60;
        pomodoroState.totalTime = pomodoroState.settings.breakTime * 60;
      } else {
        pomodoroState.currentTime = pomodoroState.settings.longBreakTime * 60;
        pomodoroState.totalTime = pomodoroState.settings.longBreakTime * 60;
      }

      document.getElementById('pomodoro-start').classList.remove('hidden');
      document.getElementById('pomodoro-pause').classList.add('hidden');

      updateDisplay();
    }

    function updateTimer() {
      pomodoroState.currentTime--;

      if (pomodoroState.currentTime <= 0) {
        completeSession();
      }

      updateDisplay();
    }

    function completeSession() {
      clearInterval(pomodoroState.timer);
      pomodoroState.isRunning = false;

      // Play completion sound
      playPomodoroSound('complete');

      // Show notification
      if (Notification.permission === 'granted') {
        new Notification(`${pomodoroState.mode === 'focus' ? 'Focus' : 'Break'} session completed!`, {
          body: pomodoroState.mode === 'focus' ? 'Time for a break!' : 'Time to focus!',
          icon: 'media/favicon.ico'
        });
      }

      // Update stats
      if (pomodoroState.mode === 'focus') {
        updateStats();
      }

      // Switch to next mode
      switchToNextMode();

      document.getElementById('pomodoro-start').classList.remove('hidden');
      document.getElementById('pomodoro-pause').classList.add('hidden');
    }

    function switchToNextMode() {
      if (pomodoroState.mode === 'focus') {
        if (pomodoroState.session % 4 === 0) {
          // Long break after 4 sessions
          pomodoroState.mode = 'longBreak';
          pomodoroState.currentTime = pomodoroState.settings.longBreakTime * 60;
          pomodoroState.totalTime = pomodoroState.settings.longBreakTime * 60;
        } else {
          // Short break
          pomodoroState.mode = 'break';
          pomodoroState.currentTime = pomodoroState.settings.breakTime * 60;
          pomodoroState.totalTime = pomodoroState.settings.breakTime * 60;
        }
      } else {
        // Back to focus
        pomodoroState.mode = 'focus';
        pomodoroState.currentTime = pomodoroState.settings.focusTime * 60;
        pomodoroState.totalTime = pomodoroState.settings.focusTime * 60;
        pomodoroState.session++;

        if (pomodoroState.session > pomodoroState.totalSessions) {
          pomodoroState.session = 1;
        }
      }

      updateDisplay();
    }

    function updateDisplay() {
      // Update timer display
      const minutes = Math.floor(pomodoroState.currentTime / 60);
      const seconds = pomodoroState.currentTime % 60;
      document.getElementById('pomodoro-timer').textContent =
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

      // Update mode display and message
      let modeText, messageText, emoji;
      if (pomodoroState.mode === 'focus') {
        modeText = 'FOCUS SESSION';
        messageText = 'Focus on your work !';
        emoji = 'üß†';
      } else if (pomodoroState.mode === 'break') {
        modeText = 'SHORT BREAK';
        messageText = 'Take a short break<br><span class="text-2xl font-bold">Relax !</span>';
        emoji = '‚òï';
      } else {
        modeText = 'LONG BREAK';
        messageText = 'Well deserved break<br><span class="text-2xl font-bold">Great job !</span>';
        emoji = 'üéâ';
      }

      document.getElementById('pomodoro-mode').textContent = modeText;
      document.getElementById('pomodoro-message').innerHTML = messageText;
      document.getElementById('pomodoro-emoji').textContent = emoji;

      // Update session display
      document.getElementById('pomodoro-session').textContent =
        `Session ${pomodoroState.session} of ${pomodoroState.totalSessions}`;

      // Update progress ring
      const progress = 1 - (pomodoroState.currentTime / pomodoroState.totalTime);
      const circumference = 2 * Math.PI * 42; // radius = 42
      const offset = circumference * (1 - progress);
      document.getElementById('pomodoro-progress').style.strokeDashoffset = offset;

      // Update progress circle color based on mode
      const progressCircle = document.getElementById('pomodoro-progress');
      if (pomodoroState.mode === 'focus') {
        progressCircle.style.stroke = '#22D3EE'; // Cyan for focus
      } else {
        progressCircle.style.stroke = '#10B981'; // Green for breaks
      }

      // Update widget background based on mode - keeping the same gradient but maybe slightly different
      const widget = document.getElementById('pomodoro-widget');
      if (pomodoroState.mode === 'focus') {
        widget.style.background = 'linear-gradient(135deg, #6578FF 0%, #B1B8EF 100%)';
      } else {
        widget.style.background = 'linear-gradient(135deg, #6578FF 0%, #B1B8EF 100%)';
      }
    }

    function adjustTime(type, amount) {
      if (pomodoroState.isRunning) return; // Can't adjust while running

      if (type === 'focus') {
        pomodoroState.settings.focusTime = Math.max(5, Math.min(60, pomodoroState.settings.focusTime + amount));
        document.getElementById('focus-time').textContent = pomodoroState.settings.focusTime + ' min';

        if (pomodoroState.mode === 'focus') {
          pomodoroState.currentTime = pomodoroState.settings.focusTime * 60;
          pomodoroState.totalTime = pomodoroState.settings.focusTime * 60;
        }
      } else if (type === 'break') {
        pomodoroState.settings.breakTime = Math.max(1, Math.min(30, pomodoroState.settings.breakTime + amount));
        document.getElementById('break-time').textContent = pomodoroState.settings.breakTime + ' min';

        if (pomodoroState.mode === 'break') {
          pomodoroState.currentTime = pomodoroState.settings.breakTime * 60;
          pomodoroState.totalTime = pomodoroState.settings.breakTime * 60;
        }
      }

      updateDisplay();
      savePomodoroSettings();
    }

    function togglePomodoroSettings() {
      const settings = document.getElementById('pomodoro-settings');
      settings.classList.toggle('hidden');
    }

    function updateStats() {
      const today = new Date().toDateString();
      let stats = JSON.parse(localStorage.getItem('pomodoroStats') || '{}');

      if (!stats[today]) {
        stats[today] = 0;
      }
      stats[today]++;

      // Calculate total sessions
      const totalSessions = Object.values(stats).reduce((sum, sessions) => sum + sessions, 0);

      localStorage.setItem('pomodoroStats', JSON.stringify(stats));

      document.getElementById('today-sessions').textContent = stats[today];
      document.getElementById('total-sessions').textContent = totalSessions;
    }

    function loadPomodoroStats() {
      const today = new Date().toDateString();
      const stats = JSON.parse(localStorage.getItem('pomodoroStats') || '{}');
      const todaySessions = stats[today] || 0;
      const totalSessions = Object.values(stats).reduce((sum, sessions) => sum + sessions, 0);

      document.getElementById('today-sessions').textContent = todaySessions;
      document.getElementById('total-sessions').textContent = totalSessions;

      // Load saved settings
      const savedSettings = JSON.parse(localStorage.getItem('pomodoroSettings') || '{}');
      if (savedSettings.focusTime) {
        pomodoroState.settings.focusTime = savedSettings.focusTime;
        document.getElementById('focus-time').textContent = savedSettings.focusTime + ' min';
      }
      if (savedSettings.breakTime) {
        pomodoroState.settings.breakTime = savedSettings.breakTime;
        document.getElementById('break-time').textContent = savedSettings.breakTime + ' min';
      }

      // Initialize display
      resetPomodoro();
    }

    function savePomodoroSettings() {
      localStorage.setItem('pomodoroSettings', JSON.stringify(pomodoroState.settings));
    }

    function playPomodoroSound(type) {
      // Create a simple beep sound using Web Audio API
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        if (type === 'complete') {
          // Three ascending beeps for completion
          [440, 554, 659].forEach((freq, i) => {
            setTimeout(() => {
              const osc = audioContext.createOscillator();
              const gain = audioContext.createGain();
              osc.connect(gain);
              gain.connect(audioContext.destination);
              osc.frequency.value = freq;
              gain.gain.setValueAtTime(0.1, audioContext.currentTime);
              gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
              osc.start(audioContext.currentTime);
              osc.stop(audioContext.currentTime + 0.3);
            }, i * 200);
          });
        } else {
          // Single beep for start
          oscillator.frequency.value = 440;
          gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.2);
        }
      } catch (e) {
        console.log('Audio not supported');
      }
    }

    // Request notification permission
    if ('Notification' in window && Notification.permission === 'default') {
      Notification.requestPermission();
    }

    // ==================== WIDGETS SLIDER FUNCTIONALITY ====================

    let currentWidgetIndex = 0;
    const widgets = [
      {
        id: 'weather',
        name: 'Weather',
        icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                 <path stroke-linecap="round" stroke-linejoin="round"
                   d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
               </svg>`
      },
      {
        id: 'notes',
        name: 'Notes',
        icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                 <path stroke-linecap="round" stroke-linejoin="round"
                   d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
               </svg>`
      },
      {
        id: 'pomodoro',
        name: 'Pomodoro',
        icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                 <circle cx="12" cy="12" r="10"/>
                 <polyline points="12,6 12,12 16,14"/>
               </svg>`
      }
    ];

    // Widget pinning functionality
    function getWidgetPinData() {
      const activeTab = localStorage.getItem("activeTab") || "personal";
      const data = JSON.parse(localStorage.getItem(`widgetPins_${activeTab}`) || '{}');
      console.log('üìñ Getting pin data for tab:', activeTab, 'Data:', data);
      return data;
    }

    function saveWidgetPinData(pinData) {
      const activeTab = localStorage.getItem("activeTab") || "personal";
      localStorage.setItem(`widgetPins_${activeTab}`, JSON.stringify(pinData));
      console.log('üíæ Saved pin data for tab:', activeTab, 'Data:', pinData);
    }

    function getCurrentWidget() {
      return widgets[currentWidgetIndex];
    }

    function getPinnedWidgetOrder() {
      const pinData = getWidgetPinData();
      const orderedWidgets = [...widgets];

      // Sort widgets by pin priority: primary first, then secondary, then unpinned
      orderedWidgets.sort((a, b) => {
        const aPinStatus = pinData[a.id] || 'none';
        const bPinStatus = pinData[b.id] || 'none';

        const priority = { 'primary': 0, 'secondary': 1, 'none': 2 };
        return priority[aPinStatus] - priority[bPinStatus];
      });

      return orderedWidgets;
    }

    function toggleWidgetPinMenu() {
      const menu = document.getElementById('widgetPinMenu');
      menu.classList.toggle('hidden');
    }

    function pinWidget(pinType) {
      console.log('üîÑ pinWidget called with:', pinType);
      const currentWidget = getCurrentWidget();
      console.log('üìç Current widget:', currentWidget);
      const pinData = getWidgetPinData();
      console.log('üíæ Current pin data:', pinData);

      // Update pin status
      pinData[currentWidget.id] = pinType;
      saveWidgetPinData(pinData);
      console.log('‚úÖ Saved pin data:', pinData);

      // Close menu
      document.getElementById('widgetPinMenu').classList.add('hidden');

      // Update widget order and display
      const orderedWidgets = getPinnedWidgetOrder();
      console.log('üîÄ New widget order:', orderedWidgets.map(w => w.id));
      const newIndex = orderedWidgets.findIndex(widget => widget.id === currentWidget.id);

      // Update the widgets array and current index
      widgets.splice(0, widgets.length, ...orderedWidgets);
      currentWidgetIndex = newIndex >= 0 ? newIndex : 0;
      console.log('üéØ New current index:', currentWidgetIndex);

      // Update display
      updateWidgetDisplay();
      updateWidgetIndicators();

      // Show notification
      const pinTypeText = pinType === 'primary' ? 'Primary' : 'Secondary';
      showNotification(`${currentWidget.name} widget pinned as ${pinTypeText}!`);
    }

    function unpinWidget() {
      const currentWidget = getCurrentWidget();
      const pinData = getWidgetPinData();

      // Remove pin status
      delete pinData[currentWidget.id];
      saveWidgetPinData(pinData);

      // Close menu
      document.getElementById('widgetPinMenu').classList.add('hidden');

      // Update widget order and display
      const orderedWidgets = getPinnedWidgetOrder();
      const newIndex = orderedWidgets.findIndex(widget => widget.id === currentWidget.id);

      // Update the widgets array and current index
      widgets.splice(0, widgets.length, ...orderedWidgets);
      currentWidgetIndex = newIndex >= 0 ? newIndex : 0;

      // Update display
      updateWidgetDisplay();
      updateWidgetIndicators();

      // Show notification
      showNotification(`${currentWidget.name} widget unpinned!`);
    }

    function initializeWidgetFunctions() {
      // This function is no longer needed since we don't rebuild widgets
    }

    function updateWidgetOrder() {
      const orderedWidgets = getPinnedWidgetOrder();
      const currentWidget = getCurrentWidget();

      // Find the current widget's new position in the ordered array
      const newIndex = orderedWidgets.findIndex(widget => widget.id === currentWidget.id);

      // Update the widgets array and current index
      widgets.splice(0, widgets.length, ...orderedWidgets);
      currentWidgetIndex = newIndex >= 0 ? newIndex : 0;

      // Update display without rebuilding
      updateWidgetDisplay();
      updateWidgetIndicators();
    }

    function updateWidgetIndicators() {
      const indicatorsContainer = document.querySelector('.flex.justify-center.gap-2.mt-0');
      indicatorsContainer.innerHTML = '';

      widgets.forEach((widget, index) => {
        const indicator = document.createElement('button');
        indicator.onclick = () => goToWidget(index);
        indicator.className = `w-2 h-2 rounded-full transition-colors duration-300 ${index === currentWidgetIndex ? 'bg-white/60' : 'bg-white/30'}`;
        indicator.id = `indicator-${index}`;
        indicatorsContainer.appendChild(indicator);
      });
    }

    function updateWidgetDisplay() {
      const slider = document.getElementById('widgets-slider');
      const titleElement = document.getElementById('current-widget-title');
      const iconElement = document.getElementById('current-widget-icon');

      // Reorder DOM elements to match the widgets array order
      reorderWidgetSlides();

      // Update slider position
      const translateX = -currentWidgetIndex * 100;
      slider.style.transform = `translateX(${translateX}%)`;

      // Update header
      titleElement.textContent = widgets[currentWidgetIndex].name;
      iconElement.innerHTML = widgets[currentWidgetIndex].icon;

      // Update indicators
      widgets.forEach((_, index) => {
        const indicator = document.getElementById(`indicator-${index}`);
        if (indicator) {
          if (index === currentWidgetIndex) {
            indicator.classList.remove('bg-white/30');
            indicator.classList.add('bg-white/60');
          } else {
            indicator.classList.remove('bg-white/60');
            indicator.classList.add('bg-white/30');
          }
        }
      });
    }

    function reorderWidgetSlides() {
      const slider = document.getElementById('widgets-slider');
      const slides = Array.from(slider.children);

      // Map widget IDs to their DOM elements
      const slideMap = {
        'weather': slides.find(slide => slide.querySelector('#weather-widget')),
        'notes': slides.find(slide => slide.querySelector('#notes-widget')),
        'pomodoro': slides.find(slide => slide.querySelector('#pomodoro-widget'))
      };

      // Remove all slides from the slider
      slides.forEach(slide => {
        if (slide.parentNode) {
          slide.parentNode.removeChild(slide);
        }
      });

      // Re-add slides in the order defined by the widgets array
      widgets.forEach(widget => {
        const slide = slideMap[widget.id];
        if (slide) {
          slider.appendChild(slide);
        }
      });
    }

    function goToWidget(index) {
      if (index >= 0 && index < widgets.length) {
        currentWidgetIndex = index;
        updateWidgetDisplay();
      }
    }

    function nextWidget() {
      currentWidgetIndex = (currentWidgetIndex + 1) % widgets.length;
      updateWidgetDisplay();
    }

    function previousWidget() {
      currentWidgetIndex = (currentWidgetIndex - 1 + widgets.length) % widgets.length;
      updateWidgetDisplay();
    }

    // Touch/swipe support for mobile
    let startX = 0;
    let isDragging = false;

    function handleTouchStart(e) {
      startX = e.touches[0].clientX;
      isDragging = true;
    }

    function handleTouchEnd(e) {
      if (!isDragging) return;

      const endX = e.changedTouches[0].clientX;
      const diffX = startX - endX;

      // Minimum swipe distance to trigger navigation
      if (Math.abs(diffX) > 50) {
        if (diffX > 0) {
          nextWidget(); // Swipe left = next
        } else {
          previousWidget(); // Swipe right = previous
        }
      }

      isDragging = false;
    }

    // Keyboard navigation
    function handleKeyNavigation(e) {
      if (e.target.tagName.toLowerCase() === 'input' || e.target.tagName.toLowerCase() === 'textarea') {
        return; // Don't interfere with input fields
      }

      if (e.key === 'ArrowLeft') {
        e.preventDefault();
        previousWidget();
      } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        nextWidget();
      }
    }

    // Initialize slider
    document.addEventListener('DOMContentLoaded', () => {
      // First load widget order based on pins, then update display
      const orderedWidgets = getPinnedWidgetOrder();
      widgets.splice(0, widgets.length, ...orderedWidgets);

      // Set initial widget index to 0 (first widget in the ordered list)
      currentWidgetIndex = 0;

      updateWidgetDisplay();

      // Add touch support
      const slider = document.getElementById('widgets-slider');
      slider.addEventListener('touchstart', handleTouchStart, { passive: true });
      slider.addEventListener('touchend', handleTouchEnd, { passive: true });

      // Add keyboard support
      document.addEventListener('keydown', handleKeyNavigation);
    });

    // Close pin menu when clicking outside
    document.addEventListener('click', (e) => {
      const pinMenu = document.getElementById('widgetPinMenu');
      const pinButton = document.getElementById('widgetPinButton');

      if (pinMenu && !pinMenu.contains(e.target) && !pinButton.contains(e.target)) {
        pinMenu.classList.add('hidden');
      }
    });

    // Search help modal functions
    function showSearchHelp() {
      document.getElementById("searchHelpModal").classList.remove("hidden");
    }

    function closeSearchHelp() {
      document.getElementById("searchHelpModal").classList.add("hidden");
    }

    // Sidebar toggle function
    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      const showBtn = document.getElementById('showSidebarBtn');
      const isCollapsed = sidebar.classList.contains('collapsed');
      
      if (isCollapsed) {
        // Show sidebar
        sidebar.classList.remove('collapsed');
        showBtn.classList.remove('collapsed');
        showBtn.title = 'Hide sidebar';
        localStorage.setItem('sidebarCollapsed', 'false');
      } else {
        // Hide sidebar
        sidebar.classList.add('collapsed');
        showBtn.classList.add('collapsed');
        showBtn.title = 'Show sidebar';
        localStorage.setItem('sidebarCollapsed', 'true');
      }
    }
    
    // Initialize sidebar state on page load
    document.addEventListener('DOMContentLoaded', () => {
      const sidebarCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
      const sidebar = document.getElementById('sidebar');
      const showBtn = document.getElementById('showSidebarBtn');
      
      if (sidebarCollapsed && sidebar && showBtn) {
        sidebar.classList.add('collapsed');
        showBtn.classList.add('collapsed');
      }
    });

  </script>

</body>

</html>